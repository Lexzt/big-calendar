{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport objectPath from 'object-path';\nimport { clone, trimDots, getHeightOfRevision } from './util';\nimport RxChangeEvent from './rx-change-event';\nimport RxError from './rx-error';\nimport { runPluginHooks } from './hooks';\nimport { BehaviorSubject } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nexport function createRxDocumentConstructor() {\n  var proto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : basePrototype;\n\n  var constructor = function RxDocument(collection, jsonData) {\n    this.collection = collection; // if true, this is a temporary document\n\n    this._isTemporary = false; // assume that this is always equal to the doc-data in the database\n\n    this._dataSync$ = new BehaviorSubject(clone(jsonData));\n    this._deleted$ = new BehaviorSubject(false);\n    this._atomicQueue = Promise.resolve();\n  };\n\n  constructor.prototype = proto;\n  return constructor;\n}\nexport var basePrototype = {\n  /**\n   * because of the prototype-merge,\n   * we can not use the native instanceof operator\n   */\n  get isInstanceOfRxDocument() {\n    return true;\n  },\n\n  get _data() {\n    return this._dataSync$.getValue();\n  },\n\n  get primaryPath() {\n    return this.collection.schema.primaryPath;\n  },\n\n  get primary() {\n    return this._data[this.primaryPath];\n  },\n\n  get revision() {\n    return this._data._rev;\n  },\n\n  get deleted$() {\n    return this._deleted$.asObservable();\n  },\n\n  get deleted() {\n    return this._deleted$.getValue();\n  },\n\n  /**\n   * returns the observable which emits the plain-data of this document\n   * @return {Observable}\n   */\n  get $() {\n    return this._dataSync$.asObservable();\n  },\n\n  /**\n   * @param {ChangeEvent}\n   */\n  _handleChangeEvent: function _handleChangeEvent(changeEvent) {\n    if (changeEvent.data.doc !== this.primary) return; // ensure that new _rev is higher then current\n\n    var newRevNr = getHeightOfRevision(changeEvent.data.v._rev);\n    var currentRevNr = getHeightOfRevision(this._data._rev);\n    if (currentRevNr > newRevNr) return;\n\n    switch (changeEvent.data.op) {\n      case 'INSERT':\n        break;\n\n      case 'UPDATE':\n        var newData = clone(changeEvent.data.v);\n\n        this._dataSync$.next(clone(newData));\n\n        break;\n\n      case 'REMOVE':\n        // remove from docCache to assure new upserted RxDocuments will be a new instance\n        this.collection._docCache[\"delete\"](this.primary);\n\n        this._deleted$.next(true);\n\n        break;\n    }\n  },\n\n  /**\n   * emits the changeEvent to the upper instance (RxCollection)\n   * @param  {RxChangeEvent} changeEvent\n   */\n  $emit: function $emit(changeEvent) {\n    return this.collection.$emit(changeEvent);\n  },\n\n  /**\n   * returns observable of the value of the given path\n   * @param {string} path\n   * @return {Observable}\n   */\n  get$: function get$(path) {\n    if (path.includes('.item.')) {\n      throw RxError.newRxError('DOC1', {\n        path: path\n      });\n    }\n\n    if (path === this.primaryPath) throw RxError.newRxError('DOC2'); // final fields cannot be modified and so also not observed\n\n    if (this.collection.schema.finalFields.includes(path)) {\n      throw RxError.newRxError('DOC3', {\n        path: path\n      });\n    }\n\n    var schemaObj = this.collection.schema.getSchemaByObjectPath(path);\n\n    if (!schemaObj) {\n      throw RxError.newRxError('DOC4', {\n        path: path\n      });\n    }\n\n    return this._dataSync$.pipe(map(function (data) {\n      return objectPath.get(data, path);\n    }), distinctUntilChanged()).asObservable();\n  },\n\n  /**\n   * populate the given path\n   * @param  {string}  path\n   * @return {Promise<RxDocument>}\n   */\n  populate: function populate(path) {\n    var schemaObj = this.collection.schema.getSchemaByObjectPath(path);\n    var value = this.get(path);\n\n    if (!schemaObj) {\n      throw RxError.newRxError('DOC5', {\n        path: path\n      });\n    }\n\n    if (!schemaObj.ref) {\n      throw RxError.newRxError('DOC6', {\n        path: path,\n        schemaObj: schemaObj\n      });\n    }\n\n    var refCollection = this.collection.database.collections[schemaObj.ref];\n\n    if (!refCollection) {\n      throw RxError.newRxError('DOC7', {\n        ref: schemaObj.ref,\n        path: path,\n        schemaObj: schemaObj\n      });\n    }\n\n    if (schemaObj.type === 'array') return Promise.all(value.map(function (id) {\n      return refCollection.findOne(id).exec();\n    }));else return refCollection.findOne(value).exec();\n  },\n\n  /**\n   * get data by objectPath\n   * @param {string} objPath\n   * @return {object} valueObj\n   */\n  get: function get(objPath) {\n    if (!this._data) return undefined;\n    var valueObj = objectPath.get(this._data, objPath);\n    valueObj = clone(valueObj); // direct return if array or non-object\n\n    if (typeof valueObj !== 'object' || Array.isArray(valueObj)) return valueObj;\n    defineGetterSetter(this.collection.schema, valueObj, objPath, this);\n    return valueObj;\n  },\n  toJSON: function toJSON() {\n    return clone(this._data);\n  },\n\n  /**\n   * set data by objectPath\n   * This can only be called on temporary documents\n   * @param {string} objPath\n   * @param {object} value\n   */\n  set: function set(objPath, value) {\n    // setters can only be used on temporary documents\n    if (!this._isTemporary) {\n      throw RxError.newRxTypeError('DOC16', {\n        objPath: objPath,\n        value: value\n      });\n    }\n\n    if (typeof objPath !== 'string') {\n      throw RxError.newRxTypeError('DOC15', {\n        objPath: objPath,\n        value: value\n      });\n    } // if equal, do nothing\n\n\n    if (Object.is(this.get(objPath), value)) return; // throw if nested without root-object\n\n    var pathEls = objPath.split('.');\n    pathEls.pop();\n    var rootPath = pathEls.join('.');\n\n    if (typeof objectPath.get(this._data, rootPath) === 'undefined') {\n      throw RxError.newRxError('DOC10', {\n        childpath: objPath,\n        rootPath: rootPath\n      });\n    }\n\n    objectPath.set(this._data, objPath, value);\n    return this;\n  },\n\n  /**\n   * updates document\n   * @overwritten by plugin (optinal)\n   * @param  {object} updateObj mongodb-like syntax\n   */\n  update: function update() {\n    throw RxError.pluginMissing('update');\n  },\n  putAttachment: function putAttachment() {\n    throw RxError.pluginMissing('attachments');\n  },\n  getAttachment: function getAttachment() {\n    throw RxError.pluginMissing('attachments');\n  },\n  allAttachments: function allAttachments() {\n    throw RxError.pluginMissing('attachments');\n  },\n\n  get allAttachments$() {\n    throw RxError.pluginMissing('attachments');\n  },\n\n  /**\n   * runs an atomic update over the document\n   * @param  {function(any)} fun that takes the document-data and returns a new data-object\n   * @return {Promise<RxDocument>}\n   */\n  atomicUpdate: function atomicUpdate(fun) {\n    var _this2 = this;\n\n    this._atomicQueue = this._atomicQueue.then(\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var oldData, newData;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              oldData = clone(_this2._dataSync$.getValue()); // use await here because it's unknown if a promise is returned\n\n              _context.next = 3;\n              return fun(clone(_this2._dataSync$.getValue()), _this2);\n\n            case 3:\n              newData = _context.sent;\n              return _context.abrupt(\"return\", _this2._saveData(newData, oldData));\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    })));\n    return this._atomicQueue.then(function () {\n      return _this2;\n    });\n  },\n  atomicSet: function atomicSet(key, value) {\n    return this.atomicUpdate(function (docData) {\n      objectPath.set(docData, key, value);\n      return docData;\n    });\n  },\n\n  /**\n   * saves the new document-data\n   * and handles the events\n   * @param {any} newData\n   * @param {any} oldData\n   * @return {Promise}\n   */\n  _saveData: function _saveData(newData, oldData) {\n    var _this3 = this;\n\n    newData = clone(newData); // deleted documents cannot be changed\n\n    if (this._deleted$.getValue()) {\n      throw RxError.newRxError('DOC11', {\n        id: this.primary,\n        document: this\n      });\n    } // ensure modifications are ok\n\n\n    this.collection.schema.validateChange(newData, oldData);\n    return this.collection._runHooks('pre', 'save', newData, this).then(function () {\n      _this3.collection.schema.validate(newData);\n\n      return _this3.collection._pouchPut(clone(newData));\n    }).then(function (ret) {\n      if (!ret.ok) {\n        throw RxError.newRxError('DOC12', {\n          data: ret\n        });\n      }\n\n      newData._rev = ret.rev; // emit event\n\n      var changeEvent = RxChangeEvent.create('UPDATE', _this3.collection.database, _this3.collection, _this3, newData);\n\n      _this3.$emit(changeEvent);\n\n      return _this3.collection._runHooks('post', 'save', newData, _this3);\n    });\n  },\n\n  /**\n   * saves the temporary document and makes a non-temporary out of it\n   * Saving a temporary doc is basically the same as RxCollection.insert()\n   * @return {boolean} false if nothing to save\n   */\n  save: function save() {\n    var _this4 = this; // .save() cannot be called on non-temporary-documents\n\n\n    if (!this._isTemporary) {\n      throw RxError.newRxError('DOC17', {\n        id: this.primary,\n        document: this\n      });\n    }\n\n    return this.collection.insert(this).then(function () {\n      _this4._isTemporary = false;\n\n      _this4.collection._docCache.set(_this4.primary, _this4); // internal events\n\n\n      _this4._dataSync$.next(clone(_this4._data));\n\n      return true;\n    });\n  },\n\n  /**\n   * remove the document,\n   * this not not equal to a pouchdb.remove(),\n   * instead we keep the values and only set _deleted: true\n   * @return {Promise<RxDocument>}\n   */\n  remove: function remove() {\n    var _this5 = this;\n\n    if (this.deleted) {\n      throw RxError.newRxError('DOC13', {\n        document: this,\n        id: this.primary\n      });\n    }\n\n    var deletedData = clone(this._data);\n    return this.collection._runHooks('pre', 'remove', deletedData, this).then(function () {\n      deletedData._deleted = true;\n      /**\n       * because pouch.remove will also empty the object,\n       * we set _deleted: true and use pouch.put\n       */\n\n      return _this5.collection._pouchPut(deletedData);\n    }).then(function () {\n      _this5.$emit(RxChangeEvent.create('REMOVE', _this5.collection.database, _this5.collection, _this5, _this5._data));\n\n      return _this5.collection._runHooks('post', 'remove', deletedData, _this5);\n    }).then(function () {\n      return _this5;\n    });\n  },\n  destroy: function destroy() {\n    throw RxError.newRxError('DOC14');\n  }\n};\nvar pseudoConstructor = createRxDocumentConstructor(basePrototype);\nvar pseudoRxDocument = new pseudoConstructor();\nexport function defineGetterSetter(schema, valueObj) {\n  var objPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var thisObj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (valueObj === null) return;\n  var pathProperties = schema.getSchemaByObjectPath(objPath);\n  if (typeof pathProperties === 'undefined') return;\n  if (pathProperties.properties) pathProperties = pathProperties.properties;\n  Object.keys(pathProperties).forEach(function (key) {\n    var fullPath = trimDots(objPath + '.' + key); // getter - value\n\n    valueObj.__defineGetter__(key, function () {\n      var _this = thisObj ? thisObj : this;\n\n      return _this.get(fullPath);\n    }); // getter - observable$\n\n\n    Object.defineProperty(valueObj, key + '$', {\n      get: function get() {\n        var _this = thisObj ? thisObj : this;\n\n        return _this.get$(fullPath);\n      },\n      enumerable: false,\n      configurable: false\n    }); // getter - populate_\n\n    Object.defineProperty(valueObj, key + '_', {\n      get: function get() {\n        var _this = thisObj ? thisObj : this;\n\n        return _this.populate(fullPath);\n      },\n      enumerable: false,\n      configurable: false\n    }); // setter - value\n\n    valueObj.__defineSetter__(key, function (val) {\n      var _this = thisObj ? thisObj : this;\n\n      return _this.set(fullPath, val);\n    });\n  });\n}\nexport function createWithConstructor(constructor, collection, jsonData) {\n  if (jsonData[collection.schema.primaryPath] && jsonData[collection.schema.primaryPath].startsWith('_design')) return null;\n  var doc = new constructor(collection, jsonData);\n  runPluginHooks('createRxDocument', doc);\n  return doc;\n}\n/**\n * returns all possible properties of a RxDocument\n * @return {string[]} property-names\n */\n\nvar _properties;\n\nexport function properties() {\n  if (!_properties) {\n    var reserved = ['deleted', 'synced'];\n    var ownProperties = Object.getOwnPropertyNames(pseudoRxDocument);\n    var prototypeProperties = Object.getOwnPropertyNames(basePrototype);\n    _properties = ownProperties.concat(prototypeProperties, reserved);\n  }\n\n  return _properties;\n}\nexport function isInstanceOf(obj) {\n  if (typeof obj === 'undefined') return false;\n  return !!obj.isInstanceOfRxDocument;\n}\nexport default {\n  createWithConstructor: createWithConstructor,\n  properties: properties,\n  createRxDocumentConstructor: createRxDocumentConstructor,\n  basePrototype: basePrototype,\n  isInstanceOf: isInstanceOf\n};","map":null,"metadata":{},"sourceType":"module"}
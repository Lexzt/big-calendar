{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter } from 'rxjs/operators';\nimport { clone, validateCouchDBString, ucfirst, nextTick, generateId, promiseSeries } from './util';\nimport RxDocument from './rx-document';\nimport RxQuery from './rx-query';\nimport RxSchema from './rx-schema';\nimport RxChangeEvent from './rx-change-event';\nimport RxError from './rx-error';\nimport DataMigrator from './data-migrator';\nimport { mustMigrate } from './data-migrator';\nimport Crypter from './crypter';\nimport DocCache from './doc-cache';\nimport QueryCache from './query-cache';\nimport ChangeEventBuffer from './change-event-buffer';\nimport overwritable from './overwritable';\nimport { runPluginHooks } from './hooks';\nexport var RxCollection =\n/*#__PURE__*/\nfunction () {\n  function RxCollection(database, name, schema) {\n    var pouchSettings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var migrationStrategies = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var methods = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    var attachments = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    var options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n    var statics = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};\n    this._isInMemory = false;\n    this.destroyed = false;\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this._migrationStrategies = migrationStrategies;\n    this._pouchSettings = pouchSettings;\n    this._methods = methods; // orm of documents\n\n    this._attachments = attachments; // orm of attachments\n\n    this.options = options;\n    this._atomicUpsertQueues = new Map();\n    this._statics = statics;\n    this._docCache = DocCache.create();\n    this._queryCache = QueryCache.create(); // defaults\n\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._repStates = [];\n    this.pouch = null; // this is needed to preserve this name\n\n    _applyHookFunctions(this);\n  }\n\n  var _proto = RxCollection.prototype;\n\n  _proto.prepare = function prepare() {\n    var _this = this;\n\n    this.pouch = this.database._spawnPouchDB(this.name, this.schema.version, this._pouchSettings);\n\n    if (this.schema.doKeyCompression()) {\n      this._keyCompressor = overwritable.createKeyCompressor(this.schema);\n    } // we trigger the non-blocking things first and await them later so we can do stuff in the mean time\n\n\n    var spawnedPouchPromise = this.pouch.info(); // resolved when the pouchdb is useable\n\n    var createIndexesPromise = _prepareCreateIndexes(this, spawnedPouchPromise);\n\n    this._dataMigrator = DataMigrator.create(this, this._migrationStrategies);\n    this._crypter = Crypter.create(this.database.password, this.schema);\n    this._observable$ = this.database.$.pipe(filter(function (event) {\n      return event.data.col === _this.name;\n    }));\n    this._changeEventBuffer = ChangeEventBuffer.create(this);\n\n    this._subs.push(this._observable$.pipe(filter(function (cE) {\n      return !cE.data.isLocal;\n    })).subscribe(function (cE) {\n      // when data changes, send it to RxDocument in docCache\n      var doc = _this._docCache.get(cE.data.doc);\n\n      if (doc) doc._handleChangeEvent(cE);\n    }));\n\n    return Promise.all([spawnedPouchPromise, createIndexesPromise]);\n  };\n  /**\n   * merge the prototypes of schema, orm-methods and document-base\n   * so we do not have to assing getters/setters and orm methods to each document-instance\n   */\n\n\n  _proto.getDocumentPrototype = function getDocumentPrototype() {\n    if (!this._getDocumentPrototype) {\n      var schemaProto = this.schema.getDocumentPrototype();\n      var ormProto = getDocumentOrmPrototype(this);\n      var baseProto = RxDocument.basePrototype;\n      var proto = {};\n      [schemaProto, ormProto, baseProto].forEach(function (obj) {\n        var props = Object.getOwnPropertyNames(obj);\n        props.forEach(function (key) {\n          var desc = Object.getOwnPropertyDescriptor(obj, key);\n          /**\n           * When enumerable is true, it will show on console.dir(instance)\n           * To not polute the output, only getters and methods are enumerable\n           */\n\n          var enumerable = true;\n          if (key.startsWith('_') || key.endsWith('_') || key.startsWith('$') || key.endsWith('$')) enumerable = false;\n\n          if (typeof desc.value === 'function') {\n            // when getting a function, we automatically do a .bind(this)\n            Object.defineProperty(proto, key, {\n              get: function get() {\n                return desc.value.bind(this);\n              },\n              enumerable: enumerable,\n              configurable: false\n            });\n          } else {\n            desc.enumerable = enumerable;\n            desc.configurable = false;\n            if (desc.writable) desc.writable = false;\n            Object.defineProperty(proto, key, desc);\n          }\n        });\n      });\n      this._getDocumentPrototype = proto;\n    }\n\n    return this._getDocumentPrototype;\n  };\n\n  _proto.getDocumentConstructor = function getDocumentConstructor() {\n    if (!this._getDocumentConstructor) {\n      this._getDocumentConstructor = RxDocument.createRxDocumentConstructor(this.getDocumentPrototype());\n    }\n\n    return this._getDocumentConstructor;\n  };\n  /**\n   * checks if a migration is needed\n   * @return {Promise<boolean>}\n   */\n\n\n  _proto.migrationNeeded = function migrationNeeded() {\n    return mustMigrate(this._dataMigrator);\n  };\n  /**\n   * @param {number} [batchSize=10] amount of documents handled in parallel\n   * @return {Observable} emits the migration-status\n   */\n\n\n  _proto.migrate = function migrate() {\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._dataMigrator.migrate(batchSize);\n  };\n  /**\n   * does the same thing as .migrate() but returns promise\n   * @param {number} [batchSize=10] amount of documents handled in parallel\n   * @return {Promise} resolves when finished\n   */\n\n\n  _proto.migratePromise = function migratePromise() {\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._dataMigrator.migratePromise(batchSize);\n  };\n  /**\n   * wrappers for Pouch.put/get to handle keycompression etc\n   */\n\n\n  _proto._handleToPouch = function _handleToPouch(docData) {\n    var data = clone(docData);\n    data = this._crypter.encrypt(data);\n    data = this.schema.swapPrimaryToId(data);\n    if (this.schema.doKeyCompression()) data = this._keyCompressor.compress(data);\n    return data;\n  };\n\n  _proto._handleFromPouch = function _handleFromPouch(docData) {\n    var noDecrypt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var data = clone(docData);\n    data = this.schema.swapIdToPrimary(data);\n    if (this.schema.doKeyCompression()) data = this._keyCompressor.decompress(data);\n    if (noDecrypt) return data;\n    data = this._crypter.decrypt(data);\n    return data;\n  };\n  /**\n   * every write on the pouchdb\n   * is tunneld throught this function\n   * @param {object} obj\n   * @param {boolean} [overwrite=false] if true, it will overwrite existing document\n   * @return {Promise}\n   */\n\n\n  _proto._pouchPut =\n  /*#__PURE__*/\n  function () {\n    var _pouchPut2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(obj) {\n      var _this2 = this;\n\n      var overwrite,\n          ret,\n          exist,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              overwrite = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n              obj = this._handleToPouch(obj);\n              ret = null;\n              _context.prev = 3;\n              _context.next = 6;\n              return this.database.lockedRun(function () {\n                return _this2.pouch.put(obj);\n              });\n\n            case 6:\n              ret = _context.sent;\n              _context.next = 22;\n              break;\n\n            case 9:\n              _context.prev = 9;\n              _context.t0 = _context[\"catch\"](3);\n\n              if (!(overwrite && _context.t0.status === 409)) {\n                _context.next = 21;\n                break;\n              }\n\n              _context.next = 14;\n              return this.database.lockedRun(function () {\n                return _this2.pouch.get(obj._id);\n              });\n\n            case 14:\n              exist = _context.sent;\n              obj._rev = exist._rev;\n              _context.next = 18;\n              return this.database.lockedRun(function () {\n                return _this2.pouch.put(obj);\n              });\n\n            case 18:\n              ret = _context.sent;\n              _context.next = 22;\n              break;\n\n            case 21:\n              throw _context.t0;\n\n            case 22:\n              return _context.abrupt(\"return\", ret);\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[3, 9]]);\n    }));\n\n    return function _pouchPut(_x) {\n      return _pouchPut2.apply(this, arguments);\n    };\n  }();\n  /**\n   * get document from pouchdb by its _id\n   * @param  {[type]} key [description]\n   * @return {[type]}     [description]\n   */\n\n\n  _proto._pouchGet = function _pouchGet(key) {\n    var _this3 = this;\n\n    return this.pouch.get(key).then(function (doc) {\n      return _this3._handleFromPouch(doc);\n    });\n  };\n  /**\n   * wrapps pouch-find\n   * @param {RxQuery} rxQuery\n   * @param {?number} limit overwrites the limit\n   * @param {?boolean} noDecrypt if true, decryption will not be made\n   * @return {Object[]} array with documents-data\n   */\n\n\n  _proto._pouchFind = function _pouchFind(rxQuery, limit) {\n    var _this4 = this;\n\n    var noDecrypt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var compressedQueryJSON = rxQuery.keyCompress();\n    if (limit) compressedQueryJSON.limit = limit;\n    return this.database.lockedRun(function () {\n      return _this4.pouch.find(compressedQueryJSON);\n    }).then(function (docsCompressed) {\n      var docs = docsCompressed.docs.map(function (doc) {\n        return _this4._handleFromPouch(doc, noDecrypt);\n      });\n      return docs;\n    });\n  };\n  /**\n   * create a RxDocument-instance from the jsonData\n   * @param {Object} json documentData\n   * @return {RxDocument}\n   */\n\n\n  _proto._createDocument = function _createDocument(json) {\n    // return from cache if exsists\n    var id = json[this.schema.primaryPath];\n\n    var cacheDoc = this._docCache.get(id);\n\n    if (cacheDoc) return cacheDoc;\n    var doc = RxDocument.createWithConstructor(this.getDocumentConstructor(), this, json);\n\n    this._docCache.set(id, doc);\n\n    this._runHooksSync('post', 'create', json, doc);\n\n    runPluginHooks('postCreateRxDocument', doc);\n    return doc;\n  };\n  /**\n   * create RxDocument from the docs-array\n   * @return {Promise<RxDocument[]>} documents\n   */\n\n\n  _proto._createDocuments = function _createDocuments(docsJSON) {\n    var _this5 = this;\n\n    return docsJSON.map(function (json) {\n      return _this5._createDocument(json);\n    });\n  };\n  /**\n   * returns observable\n   */\n\n\n  _proto.$emit = function $emit(changeEvent) {\n    return this.database.$emit(changeEvent);\n  };\n  /**\n   * @param {Object|RxDocument} json data or RxDocument if temporary\n   * @param {RxDocument} doc which was created\n   * @return {Promise<RxDocument>}\n   */\n\n\n  _proto.insert = function insert(json) {\n    var _this6 = this; // inserting a temporary-document\n\n\n    var tempDoc = null;\n\n    if (RxDocument.isInstanceOf(json)) {\n      tempDoc = json;\n\n      if (!json._isTemporary) {\n        throw RxError.newRxError('COL1', {\n          data: json\n        });\n      }\n\n      json = json.toJSON();\n    }\n\n    json = clone(json);\n    json = this.schema.fillObjectWithDefaults(json);\n\n    if (json._id && this.schema.primaryPath !== '_id') {\n      throw RxError.newRxError('COL2', {\n        data: json\n      });\n    } // fill _id\n\n\n    if (this.schema.primaryPath === '_id' && !json._id) json._id = generateId();\n    var newDoc = tempDoc;\n    return this._runHooks('pre', 'insert', json).then(function () {\n      _this6.schema.validate(json);\n\n      return _this6._pouchPut(json);\n    }).then(function (insertResult) {\n      json[_this6.schema.primaryPath] = insertResult.id;\n      json._rev = insertResult.rev;\n\n      if (tempDoc) {\n        tempDoc._dataSync$.next(json);\n      } else newDoc = _this6._createDocument(json);\n\n      return _this6._runHooks('post', 'insert', json, newDoc);\n    }).then(function () {\n      // event\n      var emitEvent = RxChangeEvent.create('INSERT', _this6.database, _this6, newDoc, json);\n\n      _this6.$emit(emitEvent);\n\n      return newDoc;\n    });\n  };\n  /**\n   * same as insert but overwrites existing document with same primary\n   * @return {Promise<RxDocument>}\n   */\n\n\n  _proto.upsert = function upsert(json) {\n    var _this7 = this;\n\n    json = clone(json);\n    var primary = json[this.schema.primaryPath];\n\n    if (!primary) {\n      throw RxError.newRxError('COL3', {\n        primaryPath: this.schema.primaryPath,\n        data: json\n      });\n    }\n\n    return this.findOne(primary).exec().then(function (existing) {\n      if (existing) {\n        json._rev = existing._rev;\n        return existing.atomicUpdate(function () {\n          return json;\n        }).then(function () {\n          return existing;\n        });\n      } else {\n        return _this7.insert(json);\n      }\n    });\n  };\n  /**\n   * upserts to a RxDocument, uses atomicUpdate if document already exists\n   * @param  {object}  json\n   * @return {Promise}\n   */\n\n\n  _proto.atomicUpsert = function atomicUpsert(json) {\n    var _this8 = this;\n\n    json = clone(json);\n    var primary = json[this.schema.primaryPath];\n\n    if (!primary) {\n      throw RxError.newRxError('COL4', {\n        data: json\n      });\n    } // ensure that it wont try 2 parallel runs\n\n\n    var queue;\n\n    if (!this._atomicUpsertQueues.has(primary)) {\n      queue = Promise.resolve();\n    } else {\n      queue = this._atomicUpsertQueues.get(primary);\n    }\n\n    queue = queue.then(function () {\n      return _atomicUpsertEnsureRxDocumentExists(_this8, primary, json);\n    }).then(function (wasInserted) {\n      if (!wasInserted.inserted) {\n        return _atomicUpsertUpdate(wasInserted.doc, json).then(function () {\n          return nextTick();\n        }) // tick here so the event can propagate\n        .then(function () {\n          return wasInserted.doc;\n        });\n      } else return wasInserted.doc;\n    });\n\n    this._atomicUpsertQueues.set(primary, queue);\n\n    return queue;\n  };\n  /**\n   * takes a mongoDB-query-object and returns the documents\n   * @param  {object} queryObj\n   * @return {RxDocument[]} found documents\n   */\n\n\n  _proto.find = function find(queryObj) {\n    if (typeof queryObj === 'string') {\n      throw RxError.newRxError('COL5', {\n        queryObj: queryObj\n      });\n    }\n\n    var query = RxQuery.create('find', queryObj, this);\n    return query;\n  };\n\n  _proto.findOne = function findOne(queryObj) {\n    var query;\n\n    if (typeof queryObj === 'string') {\n      query = RxQuery.create('findOne', {\n        _id: queryObj\n      }, this);\n    } else query = RxQuery.create('findOne', queryObj, this);\n\n    if (typeof queryObj === 'number' || Array.isArray(queryObj)) {\n      throw RxError.newRxTypeError('COL6', {\n        queryObj: queryObj\n      });\n    }\n\n    return query;\n  };\n  /**\n   * export to json\n   * @param {boolean} decrypted if true, all encrypted values will be decrypted\n   */\n\n\n  _proto.dump = function dump() {\n    throw RxError.pluginMissing('json-dump');\n  };\n  /**\n   * imports the json-data into the collection\n   * @param {Array} exportedJSON should be an array of raw-data\n   */\n\n\n  _proto.importDump = function importDump() {\n    throw RxError.pluginMissing('json-dump');\n  };\n  /**\n   * waits for external changes to the database\n   * and ensures they are emitted to the internal RxChangeEvent-Stream\n   * TODO this can be removed by listening to the pull-change-events of the RxReplicationState\n   */\n\n\n  _proto.watchForChanges = function watchForChanges() {\n    throw RxError.pluginMissing('watch-for-changes');\n  };\n  /**\n   * sync with another database\n   */\n\n\n  _proto.sync = function sync() {\n    throw RxError.pluginMissing('replication');\n  };\n  /**\n   * Create a replicated in-memory-collection\n   */\n\n\n  _proto.inMemory = function inMemory() {\n    throw RxError.pluginMissing('in-memory');\n  };\n  /**\n   * HOOKS\n   */\n\n\n  _proto.addHook = function addHook(when, key, fun) {\n    var parallel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (typeof fun !== 'function') {\n      throw RxError.newRxTypeError('COL7', {\n        key: key,\n        when: when\n      });\n    }\n\n    if (!HOOKS_WHEN.includes(when)) {\n      throw RxError.newRxTypeError('COL8', {\n        key: key,\n        when: when\n      });\n    }\n\n    if (!HOOKS_KEYS.includes(key)) {\n      throw RxError.newRxError('COL9', {\n        key: key\n      });\n    }\n\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw RxError.newRxError('COL10', {\n        when: when,\n        key: key,\n        parallel: parallel\n      });\n    } // bind this-scope to hook-function\n\n\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n\n  _proto.getHooks = function getHooks(when, key) {\n    try {\n      return this.hooks[key][when];\n    } catch (e) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n  };\n  /**\n   * @return {Promise<void>}\n   */\n\n\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return Promise.resolve(); // run parallel: false\n\n    var tasks = hooks.series.map(function (hook) {\n      return function () {\n        return hook(data, instance);\n      };\n    });\n    return promiseSeries(tasks) // run parallel: true\n    .then(function () {\n      return Promise.all(hooks.parallel.map(function (hook) {\n        return hook(data, instance);\n      }));\n    });\n  };\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */\n\n\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(function (hook) {\n      return hook(data, instance);\n    });\n  };\n  /**\n   * creates a temporaryDocument which can be saved later\n   * @param {Object} docData\n   * @return {RxDocument}\n   */\n\n\n  _proto.newDocument = function newDocument() {\n    var docData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    docData = this.schema.fillObjectWithDefaults(docData);\n    var doc = RxDocument.createWithConstructor(this.getDocumentConstructor(), this, docData);\n    doc._isTemporary = true;\n\n    this._runHooksSync('post', 'create', docData, doc);\n\n    return doc;\n  };\n  /**\n   * returns a promise that is resolved when the collection gets destroyed\n   * @return {Promise}\n   */\n\n\n  _proto.destroy = function destroy() {\n    if (this.destroyed) return;\n    this._onDestroyCall && this._onDestroyCall();\n\n    this._subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n\n    this._changeEventBuffer && this._changeEventBuffer.destroy();\n\n    this._queryCache.destroy();\n\n    this._repStates.forEach(function (sync) {\n      return sync.cancel();\n    });\n\n    delete this.database.collections[this.name];\n    this.destroyed = true;\n  };\n  /**\n   * remove all data\n   * @return {Promise}\n   */\n\n\n  _proto.remove = function remove() {\n    return this.database.removeCollection(this.name);\n  };\n\n  _createClass(RxCollection, [{\n    key: \"$\",\n    get: function get() {\n      return this._observable$;\n    }\n  }, {\n    key: \"insert$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.data.op === 'INSERT';\n      }));\n    }\n  }, {\n    key: \"update$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.data.op === 'UPDATE';\n      }));\n    }\n  }, {\n    key: \"remove$\",\n    get: function get() {\n      return this.$.pipe(filter(function (cE) {\n        return cE.data.op === 'REMOVE';\n      }));\n    }\n    /**\n     * only emits the change-events that change something with the documents\n     */\n\n  }, {\n    key: \"docChanges$\",\n    get: function get() {\n      if (!this.__docChanges$) {\n        this.__docChanges$ = this.$.pipe(filter(function (cEvent) {\n          return ['INSERT', 'UPDATE', 'REMOVE'].includes(cEvent.data.op);\n        }));\n      }\n\n      return this.__docChanges$;\n    }\n  }, {\n    key: \"onDestroy\",\n    get: function get() {\n      var _this9 = this;\n\n      if (!this._onDestroy) this._onDestroy = new Promise(function (res) {\n        return _this9._onDestroyCall = res;\n      });\n      return this._onDestroy;\n    }\n  }]);\n\n  return RxCollection;\n}();\n/**\n * checks if the migrationStrategies are ok, throws if not\n * @param  {RxSchema} schema\n * @param  {Object} migrationStrategies\n * @throws {Error|TypeError} if not ok\n * @return {boolean}\n */\n\nvar checkMigrationStrategies = function checkMigrationStrategies(schema, migrationStrategies) {\n  // migrationStrategies must be object not array\n  if (typeof migrationStrategies !== 'object' || Array.isArray(migrationStrategies)) {\n    throw RxError.newRxTypeError('COL11', {\n      schema: schema\n    });\n  } // for every previousVersion there must be strategy\n\n\n  if (schema.previousVersions.length !== Object.keys(migrationStrategies).length) {\n    throw RxError.newRxError('COL12', {\n      have: Object.keys(migrationStrategies),\n      should: schema.previousVersions\n    });\n  } // every strategy must have number as property and be a function\n\n\n  schema.previousVersions.map(function (vNr) {\n    return {\n      v: vNr,\n      s: migrationStrategies[vNr + 1 + '']\n    };\n  }).filter(function (strat) {\n    return typeof strat.s !== 'function';\n  }).forEach(function (strat) {\n    throw RxError.newRxTypeError('COL13', {\n      version: strat.v,\n      type: typeof strat,\n      schema: schema\n    });\n  });\n  return true;\n};\n\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\n\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(function (key) {\n    HOOKS_WHEN.map(function (when) {\n      var fnName = when + ucfirst(key);\n\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\n/**\n * returns all possible properties of a RxCollection-instance\n * @return {string[]} property-names\n */\n\n\nvar _properties = null;\nexport function properties() {\n  if (!_properties) {\n    var pseudoInstance = new RxCollection();\n    var ownProperties = Object.getOwnPropertyNames(pseudoInstance);\n    var prototypeProperties = Object.getOwnPropertyNames(Object.getPrototypeOf(pseudoInstance));\n    _properties = ownProperties.concat(prototypeProperties);\n  }\n\n  return _properties;\n}\n/**\n * checks if the given static methods are allowed\n * @param  {{}} statics [description]\n * @throws if not allowed\n */\n\nvar checkOrmMethods = function checkOrmMethods(statics) {\n  Object.entries(statics).forEach(function (_ref) {\n    var k = _ref[0],\n        v = _ref[1];\n\n    if (typeof k !== 'string') {\n      throw RxError.newRxTypeError('COL14', {\n        name: k\n      });\n    }\n\n    if (k.startsWith('_')) {\n      throw RxError.newRxTypeError('COL15', {\n        name: k\n      });\n    }\n\n    if (typeof v !== 'function') {\n      throw RxError.newRxTypeError('COL16', {\n        name: k,\n        type: typeof k\n      });\n    }\n\n    if (properties().includes(k) || RxDocument.properties().includes(k)) {\n      throw RxError.newRxError('COL17', {\n        name: k\n      });\n    }\n  });\n};\n/**\n * @return {Promise}\n */\n\n\nfunction _atomicUpsertUpdate(doc, json) {\n  return doc.atomicUpdate(function (innerDoc) {\n    json._rev = innerDoc._rev;\n    innerDoc._data = json;\n    return innerDoc._data;\n  }).then(function () {\n    return doc;\n  });\n}\n/**\n * ensures that the given document exists\n * @param  {string}  primary\n * @param  {any}  json\n * @return {Promise<{ doc: RxDocument, inserted: boolean}>} promise that resolves with new doc and flag if inserted\n */\n\n\nfunction _atomicUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  return rxCollection.findOne(primary).exec().then(function (doc) {\n    if (!doc) {\n      return rxCollection.insert(json).then(function (newDoc) {\n        return {\n          doc: newDoc,\n          inserted: true\n        };\n      });\n    } else {\n      return {\n        doc: doc,\n        inserted: false\n      };\n    }\n  });\n}\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n * @return {{}}\n */\n\n\nexport function getDocumentOrmPrototype(rxCollection) {\n  var proto = {};\n  Object.entries(rxCollection._methods).forEach(function (_ref2) {\n    var k = _ref2[0],\n        v = _ref2[1];\n    proto[k] = v;\n  });\n  return proto;\n}\n/**\n * creates the indexes in the pouchdb\n */\n\nfunction _prepareCreateIndexes(rxCollection, spawnedPouchPromise) {\n  return Promise.all(rxCollection.schema.indexes.map(function (indexAr) {\n    var compressedIdx = indexAr.map(function (key) {\n      if (!rxCollection.schema.doKeyCompression()) return key;else return rxCollection._keyCompressor.transformKey('', '', key.split('.'));\n    });\n    return spawnedPouchPromise.then(function () {\n      return rxCollection.pouch.createIndex({\n        index: {\n          fields: compressedIdx\n        }\n      });\n    });\n  }));\n}\n/**\n * creates and prepares a new collection\n * @param  {RxDatabase}  database\n * @param  {string}  name\n * @param  {RxSchema}  schema\n * @param  {?Object}  [pouchSettings={}]\n * @param  {?Object}  [migrationStrategies={}]\n * @return {Promise<RxCollection>} promise with collection\n */\n\n\nexport function create(_ref3) {\n  var database = _ref3.database,\n      name = _ref3.name,\n      schema = _ref3.schema,\n      _ref3$pouchSettings = _ref3.pouchSettings,\n      pouchSettings = _ref3$pouchSettings === void 0 ? {} : _ref3$pouchSettings,\n      _ref3$migrationStrate = _ref3.migrationStrategies,\n      migrationStrategies = _ref3$migrationStrate === void 0 ? {} : _ref3$migrationStrate,\n      _ref3$autoMigrate = _ref3.autoMigrate,\n      autoMigrate = _ref3$autoMigrate === void 0 ? true : _ref3$autoMigrate,\n      _ref3$statics = _ref3.statics,\n      statics = _ref3$statics === void 0 ? {} : _ref3$statics,\n      _ref3$methods = _ref3.methods,\n      methods = _ref3$methods === void 0 ? {} : _ref3$methods,\n      _ref3$attachments = _ref3.attachments,\n      attachments = _ref3$attachments === void 0 ? {} : _ref3$attachments,\n      _ref3$options = _ref3.options,\n      options = _ref3$options === void 0 ? {} : _ref3$options;\n  validateCouchDBString(name); // ensure it is a schema-object\n\n  if (!RxSchema.isInstanceOf(schema)) schema = RxSchema.create(schema);\n  checkMigrationStrategies(schema, migrationStrategies); // check ORM-methods\n\n  checkOrmMethods(statics);\n  checkOrmMethods(methods);\n  checkOrmMethods(attachments);\n  Object.keys(methods).filter(function (funName) {\n    return schema.topLevelFields.includes(funName);\n  }).forEach(function (funName) {\n    throw RxError.newRxError('COL18', {\n      funName: funName\n    });\n  });\n  var collection = new RxCollection(database, name, schema, pouchSettings, migrationStrategies, methods, attachments, options, statics);\n  return collection.prepare().then(function () {\n    // ORM add statics\n    Object.entries(statics).forEach(function (_ref4) {\n      var funName = _ref4[0],\n          fun = _ref4[1];\n      return collection.__defineGetter__(funName, function () {\n        return fun.bind(collection);\n      });\n    });\n    var ret = Promise.resolve();\n    if (autoMigrate) ret = collection.migratePromise();\n    return ret;\n  }).then(function () {\n    runPluginHooks('createRxCollection', collection);\n    return collection;\n  });\n}\nexport function isInstanceOf(obj) {\n  return obj instanceof RxCollection;\n}\nexport default {\n  create: create,\n  properties: properties,\n  isInstanceOf: isInstanceOf,\n  RxCollection: RxCollection\n};","map":null,"metadata":{},"sourceType":"module"}
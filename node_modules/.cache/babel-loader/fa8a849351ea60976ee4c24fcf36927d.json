{"ast":null,"code":"import { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { promiseWait, nextTick } from '../util';\nimport RxChangeEvent from '../rx-change-event';\n/**\n * listens to changes of the internal pouchdb\n * and ensures they are emitted to the internal RxChangeEvent-Stream\n */\n\nexport function watchForChanges() {\n  var _this = this; // do not call twice on same collection\n\n\n  if (this.synced) return;\n  this.synced = true;\n  this._watchForChangesUnhandled = new Set();\n  /**\n   * this will grap the changes and publish them to the rx-stream\n   * this is to ensure that changes from 'synced' dbs will be published\n   */\n\n  var pouch$ = fromEvent(this.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(map(function (ar) {\n    return ar[0];\n  }) // rxjs6.x fires an array for whatever reason\n  ).subscribe(function (change) {\n    var resPromise = _handleSingleChange(_this, change); // add and remove to the Set so RxReplicationState.complete$ can know when all events where handled\n\n\n    _this._watchForChangesUnhandled.add(resPromise);\n\n    resPromise.then(function () {\n      _this._watchForChangesUnhandled[\"delete\"](resPromise);\n    });\n  });\n\n  this._subs.push(pouch$);\n}\n/**\n * handles a single change-event\n * and ensures that it is not already handled\n * @param {RxCollection} collection\n * @param {*} change\n * @return {Promise<boolean>}\n */\n\nfunction _handleSingleChange(collection, change) {\n  if (change.id.charAt(0) === '_') return Promise.resolve(false); // do not handle changes of internal docs\n  // wait 2 ticks and 20 ms to give the internal event-handling time to run\n\n  return promiseWait(20).then(function () {\n    return nextTick();\n  }).then(function () {\n    return nextTick();\n  }).then(function () {\n    var docData = change.doc; // already handled by internal event-stream\n\n    if (collection._changeEventBuffer.hasChangeWithRevision(docData._rev)) return Promise.resolve(false);\n    var cE = RxChangeEvent.fromPouchChange(docData, collection);\n    collection.$emit(cE);\n    return true;\n  });\n}\n\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.watchForChanges = watchForChanges;\n  }\n};\nexport default {\n  rxdb: rxdb,\n  prototypes: prototypes\n};","map":null,"metadata":{},"sourceType":"module"}
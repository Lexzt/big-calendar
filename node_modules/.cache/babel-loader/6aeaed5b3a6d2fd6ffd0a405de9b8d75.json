{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sham/big-calendar/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/sham/big-calendar/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { map, mergeMap, switchMap, catchError } from 'rxjs/operators';\nimport { ofType } from 'redux-observable';\nimport { from } from 'rxjs';\nimport md5 from 'md5';\nimport { RETRIEVE_STORED_EVENTS, BEGIN_STORE_EVENTS, duplicateAction, updateStoredEvents, successStoringEvents, failStoringEvents, beginStoringEvents } from '../../actions/db/events';\nimport { POST_EVENT_SUCCESS, GET_EVENTS_SUCCESS } from '../../actions/events';\nimport getDb from '../../db';\nexport var retrieveEventsEpic = function retrieveEventsEpic(action$) {\n  return action$.pipe(ofType(RETRIEVE_STORED_EVENTS), mergeMap(function () {\n    return from(getDb()).pipe(mergeMap(function (db) {\n      return from(db.events.find().exec()).pipe(map(function (events) {\n        return events.map(function (singleEvent) {\n          return {\n            'id': md5(singleEvent.id),\n            'end': singleEvent.end,\n            'start': singleEvent.start,\n            'summary': singleEvent.summary,\n            'organizer': singleEvent.organizer,\n            'recurrence': singleEvent.recurrence,\n            'iCalUID': singleEvent.iCalUID,\n            'attendees': singleEvent.attendees\n          };\n        });\n      }), map(function (results) {\n        return updateStoredEvents(results);\n      }));\n    }));\n  }));\n};\nexport var storeEventsEpic = function storeEventsEpic(action$) {\n  return action$.pipe(ofType(BEGIN_STORE_EVENTS), map(function (_ref) {\n    var payload = _ref.payload;\n    return filter(payload);\n  }), mergeMap(function (payload) {\n    return from(storeEvents(payload)).pipe(map(function (results) {\n      return successStoringEvents(results);\n    }), catchError(function (error) {\n      return failStoringEvents(error);\n    }));\n  }));\n};\nexport var beginStoreEventsEpic = function beginStoreEventsEpic(action$) {\n  return action$.pipe(ofType(POST_EVENT_SUCCESS, GET_EVENTS_SUCCESS), map(function (_ref2) {\n    var payload = _ref2.payload;\n    return beginStoringEvents(payload);\n  }));\n};\n\nfunction storeEvents(_x) {\n  return _storeEvents.apply(this, arguments);\n}\n\nfunction _storeEvents() {\n  _storeEvents = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(events) {\n    var db, addEvents, results, values;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return getDb();\n\n          case 2:\n            db = _context2.sent;\n            debugger;\n            addEvents = [];\n            results = events.map(\n            /*#__PURE__*/\n            function () {\n              var _ref3 = _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee(dbEvent) {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!dbEvent.id) {\n                          _context.next = 10;\n                          break;\n                        }\n\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return db.events.upsert(dbEvent);\n\n                      case 4:\n                        _context.next = 9;\n                        break;\n\n                      case 6:\n                        _context.prev = 6;\n                        _context.t0 = _context[\"catch\"](1);\n                        return _context.abrupt(\"return\", _context.t0);\n\n                      case 9:\n                        return _context.abrupt(\"return\", dbEvent);\n\n                      case 10:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, this, [[1, 6]]);\n              }));\n\n              return function (_x2) {\n                return _ref3.apply(this, arguments);\n              };\n            }());\n            _context2.next = 8;\n            return Promise.all(results);\n\n          case 8:\n            values = _context2.sent;\n            debugger;\n            return _context2.abrupt(\"return\", values);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n  return _storeEvents.apply(this, arguments);\n}\n\nvar filter = function filter(events) {\n  if (events.data !== undefined) {\n    debugger;\n    var formated_events = events.data.entities.events.map(function (eachEvent) {\n      return {\n        'id': md5(eachEvent.id),\n        'end': eachEvent.end,\n        'start': eachEvent.start,\n        'summary': eachEvent.summary,\n        'organizer': eachEvent.organizer,\n        'recurrence': eachEvent.recurrence,\n        'iCalUID': eachEvent.iCalUID,\n        'attendees': eachEvent.attendees\n      };\n    });\n    return formated_events;\n  } else {\n    return [];\n  }\n};","map":{"version":3,"sources":["/Users/sham/big-calendar/src/epics/db/events.js"],"names":["map","mergeMap","switchMap","catchError","ofType","from","md5","RETRIEVE_STORED_EVENTS","BEGIN_STORE_EVENTS","duplicateAction","updateStoredEvents","successStoringEvents","failStoringEvents","beginStoringEvents","POST_EVENT_SUCCESS","GET_EVENTS_SUCCESS","getDb","retrieveEventsEpic","action$","pipe","db","events","find","exec","singleEvent","id","end","start","summary","organizer","recurrence","iCalUID","attendees","results","storeEventsEpic","payload","filter","storeEvents","error","beginStoreEventsEpic","addEvents","dbEvent","upsert","Promise","all","values","data","undefined","formated_events","entities","eachEvent"],"mappings":"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","sourcesContent":["import { map, mergeMap, switchMap, catchError } from 'rxjs/operators';\nimport { ofType } from 'redux-observable';\nimport { from } from 'rxjs';\nimport md5 from 'md5';\nimport {\n  RETRIEVE_STORED_EVENTS,\n  BEGIN_STORE_EVENTS,\n  duplicateAction,\n  updateStoredEvents,\n  successStoringEvents,\n  failStoringEvents,\n  beginStoringEvents\n} from '../../actions/db/events';\nimport {\n  POST_EVENT_SUCCESS,\n  GET_EVENTS_SUCCESS\n} from '../../actions/events';\nimport getDb from '../../db';\n\nexport const retrieveEventsEpic = action$ => action$.pipe(\n  ofType(RETRIEVE_STORED_EVENTS),\n  mergeMap(() => from(getDb()).pipe(\n    mergeMap(db => from(db.events.find().exec()).pipe(\n        map(events => events.map(singleEvent => {\n              return {\n                  'id' : md5(singleEvent.id),\n                  'end' : singleEvent.end,\n                  'start': singleEvent.start,\n                  'summary': singleEvent.summary,\n                  'organizer': singleEvent.organizer,\n                  'recurrence': singleEvent.recurrence,\n                  'iCalUID': singleEvent.iCalUID,\n                  'attendees': singleEvent.attendees\n                }\n          })\n        ),\n        map(results => {\n          return updateStoredEvents(results);\n            })\n          )\n        )\n      ),\n    ),\n  )\n\nexport const storeEventsEpic = action$ => action$.pipe(\n    ofType(BEGIN_STORE_EVENTS),\n    map(({payload}) => filter(payload)),\n    mergeMap((payload) => from(storeEvents(payload)).pipe(\n      map(results => successStoringEvents(results)),\n      catchError(error => failStoringEvents(error))\n    ))\n  )\n\nexport const beginStoreEventsEpic = action$ => action$.pipe(\n  ofType(POST_EVENT_SUCCESS, GET_EVENTS_SUCCESS),\n  map(({ payload }) => beginStoringEvents(payload))\n)\n\n\nasync function storeEvents(events){\n      const db = await getDb();\n      debugger\n      const addEvents = [];\n      const results = events.map(async dbEvent => {\n        if(!!dbEvent.id) {\n          try {\n            await db.events.upsert(dbEvent);\n          } catch(e) {\n            return e;\n          }\n          return dbEvent;\n        }\n      });\n      let values = await Promise.all(results);\n      debugger\n      return values;\n  }\n\nconst filter = (events) => {\n    if(events.data !== undefined) {\n      debugger\n      const formated_events = events.data.entities.events\n      .map(eachEvent => {\n          return  ({\n            'id' : md5(eachEvent.id),\n            'end' : eachEvent.end,\n            'start': eachEvent.start,\n            'summary': eachEvent.summary,\n            'organizer': eachEvent.organizer,\n            'recurrence': eachEvent.recurrence,\n            'iCalUID': eachEvent.iCalUID,\n            'attendees': eachEvent.attendees\n          })\n        }\n      );\n      return formated_events;\n    }\n    else {\n      return [];\n    }\n  }\n"]},"metadata":{},"sourceType":"module"}
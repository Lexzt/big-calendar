{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\n/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\n\nimport { Subject, fromEvent as ObservableFromEvent } from 'rxjs';\nimport { filter, map, mergeMap, first } from 'rxjs/operators';\nimport RxCollection from '../rx-collection';\nimport { clone, randomCouchString, adapterObject } from '../util';\nimport Core from '../core';\nimport Crypter from '../crypter';\nimport ChangeEventBuffer from '../change-event-buffer';\nimport RxSchema from '../rx-schema';\nimport PouchDB from '../pouch-db';\nimport RxError from '../rx-error'; // add the watch-for-changes-plugin\n\nimport RxDBWatchForChangesPlugin from '../plugins/watch-for-changes';\nCore.plugin(RxDBWatchForChangesPlugin);\nvar collectionCacheMap = new WeakMap();\nvar collectionPromiseCacheMap = new WeakMap();\nvar BULK_DOC_OPTIONS = {\n  new_edits: true\n};\nexport var InMemoryRxCollection =\n/*#__PURE__*/\nfunction (_RxCollection$RxColle) {\n  _inheritsLoose(InMemoryRxCollection, _RxCollection$RxColle);\n\n  function InMemoryRxCollection(parentCollection) {\n    var _this;\n\n    var pouchSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _this = _RxCollection$RxColle.call(this, parentCollection.database, parentCollection.name, toCleanSchema(parentCollection.schema), pouchSettings, // pouchSettings\n    {}, parentCollection._methods) || this;\n    _this._isInMemory = true;\n    _this._parentCollection = parentCollection;\n\n    _this._parentCollection.onDestroy.then(function () {\n      return _this.destroy();\n    });\n\n    _this._crypter = Crypter.create(_this.database.password, _this.schema);\n    _this._changeStreams = [];\n    /**\n     * runs on parentCollection.destroy()\n     * Cleans up everything to free up memory\n     */\n\n    _this.onDestroy.then(function () {\n      _this._changeStreams.forEach(function (stream) {\n        return stream.cancel();\n      });\n\n      _this.pouch.destroy();\n    }); // add orm functions and options from parent\n\n\n    _this.options = parentCollection.options;\n    Object.entries(parentCollection._statics).forEach(function (_ref) {\n      var funName = _ref[0],\n          fun = _ref[1];\n      return _this.__defineGetter__(funName, function () {\n        return fun.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n      });\n    });\n    _this.pouch = new PouchDB('rxdb-in-memory-' + randomCouchString(10), adapterObject('memory'), {});\n    _this._observable$ = new Subject();\n    _this._changeEventBuffer = ChangeEventBuffer.create(_assertThisInitialized(_assertThisInitialized(_this)));\n    var parentProto = Object.getPrototypeOf(parentCollection);\n    _this._oldPouchPut = parentProto._pouchPut.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._nonPersistentRevisions = new Set();\n    _this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n\n    return _this;\n  }\n\n  var _proto = InMemoryRxCollection.prototype;\n\n  _proto.prepare =\n  /*#__PURE__*/\n  function () {\n    var _prepare = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var _this2 = this;\n\n      var thisToParentSub, parentToThisSub;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return setIndexes(this.schema, this.pouch);\n\n            case 2:\n              this._subs.push(this._observable$.subscribe(function (cE) {\n                // when data changes, send it to RxDocument in docCache\n                var doc = _this2._docCache.get(cE.data.doc);\n\n                if (doc) doc._handleChangeEvent(cE);\n              }));\n              /* REPLICATION BETWEEN THIS AND PARENT */\n              // initial sync parent's docs to own\n\n\n              _context.next = 5;\n              return replicateExistingDocuments(this._parentCollection, this);\n\n            case 5:\n              /**\n               * call watchForChanges() on both sides,\n               * to ensure none-rxdb-changes like replication\n               * will fire into the change-event-stream\n               */\n              this._parentCollection.watchForChanges();\n\n              this.watchForChanges();\n              /**\n               * create an ongoing replications between both sides\n               */\n\n              thisToParentSub = streamChangedDocuments(this).pipe(mergeMap(function (doc) {\n                return applyChangedDocumentToPouch(_this2._parentCollection, doc).then(function () {\n                  return doc._rev;\n                });\n              })).subscribe(function (changeRev) {\n                _this2._nonPersistentRevisions[\"delete\"](changeRev);\n\n                _this2._nonPersistentRevisionsSubject.next(_this2._nonPersistentRevisions.size);\n              });\n\n              this._subs.push(thisToParentSub);\n\n              parentToThisSub = streamChangedDocuments(this._parentCollection).subscribe(function (doc) {\n                return applyChangedDocumentToPouch(_this2, doc);\n              });\n\n              this._subs.push(parentToThisSub);\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function prepare() {\n      return _prepare.apply(this, arguments);\n    };\n  }();\n  /**\n   * waits until all writes are persistent\n   * in the parent collection\n   * @return {Promise}\n   */\n\n\n  _proto.awaitPersistence = function awaitPersistence() {\n    var _this3 = this;\n\n    if (this._nonPersistentRevisions.size === 0) return Promise.resolve();\n    return this._nonPersistentRevisionsSubject.pipe(filter(function () {\n      return _this3._nonPersistentRevisions.size === 0;\n    }), first()).toPromise();\n  };\n  /**\n   * To know which events are replicated and which are not,\n   * the _pouchPut is wrapped\n   * @overwrite\n   */\n\n\n  _proto._pouchPut =\n  /*#__PURE__*/\n  function () {\n    var _pouchPut2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(obj, overwrite) {\n      var ret;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this._oldPouchPut(obj, overwrite);\n\n            case 2:\n              ret = _context2.sent;\n\n              this._nonPersistentRevisions.add(ret.rev);\n\n              return _context2.abrupt(\"return\", ret);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    return function _pouchPut(_x, _x2) {\n      return _pouchPut2.apply(this, arguments);\n    };\n  }();\n  /**\n   * @overwrite\n   */\n\n\n  _proto.$emit = function $emit(changeEvent) {\n    if (this._changeEventBuffer.hasChangeWithRevision(changeEvent.data.v && changeEvent.data.v._rev)) return;\n\n    this._observable$.next(changeEvent); // run compaction each 10 events\n\n\n    if (!this._eventCounter) this._eventCounter = 0;\n    this._eventCounter++;\n\n    if (this._eventCounter === 10) {\n      this._eventCounter = 0;\n      this.pouch.compact();\n    }\n  };\n  /**\n   * @overwrite\n   * Replication on the inMemory is dangerous,\n   * replicate with it's parent instead\n   */\n\n\n  _proto.sync = function sync() {\n    throw RxError.newRxError('IM2');\n  };\n\n  return InMemoryRxCollection;\n}(RxCollection.RxCollection);\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n * @param  {RxSchema} rxSchema\n * @return {RxSchema}\n */\n\nfunction toCleanSchema(rxSchema) {\n  var newSchemaJson = clone(rxSchema.jsonID);\n  newSchemaJson.keyCompression = false;\n  delete newSchemaJson.properties._id;\n  delete newSchemaJson.properties._rev;\n  delete newSchemaJson.properties._attachments;\n\n  var removeEncryption = function removeEncryption(schema, complete) {\n    delete schema.encrypted;\n    Object.values(schema).filter(function (val) {\n      return typeof val === 'object';\n    }).forEach(function (val) {\n      return removeEncryption(val, complete);\n    });\n  };\n\n  removeEncryption(newSchemaJson, newSchemaJson);\n  return RxSchema.create(newSchemaJson);\n}\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @param  {RxCollection} fromCollection\n * @param  {RxCollection} toCollection\n * @return {Promise<{}[]>} Promise that resolves with an array of the docs data\n */\n\n\nexport function replicateExistingDocuments(fromCollection, toCollection) {\n  return fromCollection.pouch.allDocs({\n    attachments: false,\n    include_docs: true\n  }).then(function (allRows) {\n    var docs = allRows.rows.map(function (row) {\n      return row.doc;\n    }).filter(function (doc) {\n      return !doc.language;\n    }) // do not replicate design-docs\n    .map(function (doc) {\n      return fromCollection._handleFromPouch(doc);\n    }) // swap back primary because keyCompression:false\n    .map(function (doc) {\n      return fromCollection.schema.swapPrimaryToId(doc);\n    });\n    if (docs.length === 0) return []; // nothing to replicate\n    else {\n        return toCollection.pouch.bulkDocs({\n          docs: docs\n        }, {\n          new_edits: false\n        }).then(function () {\n          return docs;\n        });\n      }\n  });\n}\n/**\n * sets the indexes from the schema at the pouchdb\n * @param {RxSchema} schema\n * @param {PouchDB} pouch\n * @return {Promise<void>}\n */\n\nexport function setIndexes(schema, pouch) {\n  return Promise.all(schema.indexes.map(function (indexAr) {\n    return pouch.createIndex({\n      index: {\n        fields: indexAr\n      }\n    });\n  }));\n}\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param {RxCollection} rxCollection\n * @param {Function?} prevFilter can be used to filter changes before doing anything\n * @return {Observable<any>} observable that emits document-data\n */\n\nexport function streamChangedDocuments(rxCollection) {\n  var prevFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n    return true;\n  };\n  if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n  var observable = ObservableFromEvent(rxCollection.pouch.changes({\n    since: 'now',\n    live: true,\n    include_docs: true\n  }), 'change').pipe(map(function (changeAr) {\n    return changeAr[0];\n  }), // rxjs emits an array for whatever reason\n  filter(function (change) {\n    // changes on the doNotEmit-list shell not be fired\n    var emitFlag = change.id + ':' + change.doc._rev;\n    if (rxCollection._doNotEmitSet.has(emitFlag)) return false;else return true;\n  }), filter(function (change) {\n    return prevFilter(change);\n  }), map(function (change) {\n    return rxCollection._handleFromPouch(change.doc);\n  }));\n  return observable;\n}\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n * @param  {RxCollection} rxCollection\n * @param  {any} docData\n * @return {Promise<any>} promise that resolved with the transformed doc-data\n */\n\nexport function applyChangedDocumentToPouch(_x3, _x4) {\n  return _applyChangedDocumentToPouch.apply(this, arguments);\n}\n\nfunction _applyChangedDocumentToPouch() {\n  _applyChangedDocumentToPouch = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(rxCollection, docData) {\n    var transformedDoc, oldDoc, bulkRet, emitFlag;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!rxCollection._doNotEmitSet) rxCollection._doNotEmitSet = new Set();\n            transformedDoc = rxCollection._handleToPouch(docData);\n            _context3.prev = 2;\n            _context3.next = 5;\n            return rxCollection.pouch.get(transformedDoc._id);\n\n          case 5:\n            oldDoc = _context3.sent;\n            transformedDoc._rev = oldDoc._rev;\n            _context3.next = 12;\n            break;\n\n          case 9:\n            _context3.prev = 9;\n            _context3.t0 = _context3[\"catch\"](2); // doc not found, do not use a revision\n\n            delete transformedDoc._rev;\n\n          case 12:\n            _context3.next = 14;\n            return rxCollection.pouch.bulkDocs({\n              docs: [transformedDoc]\n            }, BULK_DOC_OPTIONS);\n\n          case 14:\n            bulkRet = _context3.sent;\n\n            if (!(bulkRet.length > 0 && !bulkRet[0].ok)) {\n              _context3.next = 17;\n              break;\n            }\n\n            throw new Error(JSON.stringify(bulkRet[0]));\n\n          case 17:\n            // set the flag so this does not appear in the own event-stream again\n            emitFlag = transformedDoc._id + ':' + bulkRet[0].rev;\n\n            rxCollection._doNotEmitSet.add(emitFlag); // remove from the list later to not have a memory-leak\n\n\n            setTimeout(function () {\n              return rxCollection._doNotEmitSet[\"delete\"](emitFlag);\n            }, 30 * 1000);\n            return _context3.abrupt(\"return\", transformedDoc);\n\n          case 21:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this, [[2, 9]]);\n  }));\n  return _applyChangedDocumentToPouch.apply(this, arguments);\n}\n\nvar INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n * @return {Promise<RxCollection>}\n */\n\nexport function spawnInMemory() {\n  return _spawnInMemory.apply(this, arguments);\n}\n\nfunction _spawnInMemory() {\n  _spawnInMemory = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4() {\n    var col, preparePromise;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (INIT_DONE) {\n              _context4.next = 4;\n              break;\n            }\n\n            INIT_DONE = true; // ensure memory-adapter is added\n\n            if (!(!PouchDB.adapters || !PouchDB.adapters.memory)) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw RxError.newRxError('IM1');\n\n          case 4:\n            if (!collectionCacheMap.has(this)) {\n              _context4.next = 8;\n              break;\n            }\n\n            _context4.next = 7;\n            return collectionPromiseCacheMap.get(this);\n\n          case 7:\n            return _context4.abrupt(\"return\", collectionCacheMap.get(this));\n\n          case 8:\n            col = new InMemoryRxCollection(this);\n            preparePromise = col.prepare();\n            collectionCacheMap.set(this, col);\n            collectionPromiseCacheMap.set(this, preparePromise);\n            _context4.next = 14;\n            return preparePromise;\n\n          case 14:\n            return _context4.abrupt(\"return\", col);\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this);\n  }));\n  return _spawnInMemory.apply(this, arguments);\n}\n\nexport var rxdb = true;\nexport var prototypes = {\n  RxCollection: function RxCollection(proto) {\n    proto.inMemory = spawnInMemory;\n  }\n};\nexport var overwritable = {};\nexport default {\n  rxdb: rxdb,\n  prototypes: prototypes,\n  overwritable: overwritable,\n  spawnInMemory: spawnInMemory\n};","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport deepEqual from 'deep-equal';\nimport MQuery from './mquery/mquery';\nimport { sortObject, stringifyFilter, clone } from './util';\nimport QueryChangeDetector from './query-change-detector';\nimport RxError from './rx-error';\nimport { runPluginHooks } from './hooks';\nimport { merge, BehaviorSubject } from 'rxjs';\nimport { mergeMap, filter, map, first, tap } from 'rxjs/operators';\nvar _queryCount = 0;\n\nvar newQueryID = function newQueryID() {\n  return ++_queryCount;\n};\n\nexport var RxQuery =\n/*#__PURE__*/\nfunction () {\n  function RxQuery(op, queryObj, collection) {\n    this.op = op;\n    this.collection = collection;\n    this.id = newQueryID();\n    if (!queryObj) queryObj = _getDefaultQuery(this.collection);\n    this.mquery = new MQuery(queryObj);\n    this._subs = []; // contains the results as plain json-data\n\n    this._resultsData = null; // contains the results as RxDocument[]\n\n    this._resultsDocs$ = new BehaviorSubject(null);\n    this._queryChangeDetector = QueryChangeDetector.create(this); // stores the changeEvent-Number of the last handled change-event\n\n    this._latestChangeEvent = -1;\n    /**\n     * counts how often the execution on the whole db was done\n     * (used for tests and debugging)\n     * @type {Number}\n     */\n\n    this._execOverDatabaseCount = 0;\n    this._ensureEqualQueue = Promise.resolve();\n  }\n\n  var _proto = RxQuery.prototype;\n\n  _proto.toString = function toString() {\n    if (!this.stringRep) {\n      var stringObj = sortObject({\n        op: this.op,\n        options: this.mquery.options,\n        _conditions: this.mquery._conditions,\n        _path: this.mquery._path,\n        _fields: this.mquery._fields\n      }, true);\n      this.stringRep = JSON.stringify(stringObj, stringifyFilter);\n    }\n\n    return this.stringRep;\n  }; // returns a clone of this RxQuery\n\n\n  _proto._clone = function _clone() {\n    var cloned = new RxQuery(this.op, _getDefaultQuery(this.collection), this.collection);\n    cloned.mquery = this.mquery.clone();\n    return cloned;\n  };\n  /**\n   * set the new result-data as result-docs of the query\n   * @param {{}[]} newResultData json-docs that were recieved from pouchdb\n   * @return {RxDocument[]}\n   */\n\n\n  _proto._setResultData = function _setResultData(newResultData) {\n    this._resultsData = newResultData;\n\n    var docs = this.collection._createDocuments(this._resultsData);\n\n    this._resultsDocs$.next(docs);\n\n    return docs;\n  };\n  /**\n   * executes the query on the database\n   * @return {Promise<{}[]>} results-array with document-data\n   */\n\n\n  _proto._execOverDatabase = function _execOverDatabase() {\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    var docsPromise;\n\n    switch (this.op) {\n      case 'find':\n        docsPromise = this.collection._pouchFind(this);\n        break;\n\n      case 'findOne':\n        docsPromise = this.collection._pouchFind(this, 1);\n        break;\n\n      default:\n        throw RxError.newRxError('QU1', {\n          op: this.op\n        });\n    }\n\n    return docsPromise;\n  };\n  /**\n   * Returns an observable that emits the results\n   * This should behave like an rxjs-BehaviorSubject which means:\n   * - Emit the current result-set on subscribe\n   * - Emit the new result-set when an RxChangeEvent comes in\n   * - Do not emit anything before the first result-set was created (no null)\n   * @return {BehaviorSubject<RxDocument[]>}\n   */\n\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   * @return {Promise<RxDocument|RxDocument[]>} found documents\n   */\n\n\n  _proto.exec =\n  /*#__PURE__*/\n  function () {\n    var _exec = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var _this = this;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", _ensureEqual(this).then(function () {\n                return _this.$.pipe(first()).toPromise();\n              }));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function exec() {\n      return _exec.apply(this, arguments);\n    };\n  }();\n\n  _proto.toJSON = function toJSON() {\n    if (this._toJSON) return this._toJSON;\n    var primPath = this.collection.schema.primaryPath;\n    var json = {\n      selector: this.mquery._conditions\n    };\n    var options = clone(this.mquery.options); // sort\n\n    if (options.sort) {\n      var sortArray = [];\n      Object.keys(options.sort).map(function (fieldName) {\n        var dirInt = options.sort[fieldName];\n        var dir = 'asc';\n        if (dirInt === -1) dir = 'desc';\n        var pushMe = {}; // TODO run primary-swap somewhere else\n\n        if (fieldName === primPath) fieldName = '_id';\n        pushMe[fieldName] = dir;\n        sortArray.push(pushMe);\n      });\n      json.sort = sortArray;\n    }\n\n    if (options.limit) {\n      if (typeof options.limit !== 'number') {\n        throw RxError.newRxTypeError('QU2', {\n          limit: options.limit\n        });\n      }\n\n      json.limit = options.limit;\n    }\n\n    if (options.skip) {\n      if (typeof options.skip !== 'number') {\n        throw RxError.newRxTypeError('QU3', {\n          skip: options.skip\n        });\n      }\n\n      json.skip = options.skip;\n    } // strip empty selectors\n\n\n    Object.entries(json.selector).filter(function (_ref) {\n      var v = _ref[1];\n      return typeof v === 'object';\n    }).filter(function (_ref2) {\n      var v = _ref2[1];\n      return v !== null;\n    }).filter(function (_ref3) {\n      var v = _ref3[1];\n      return !Array.isArray(v);\n    }).filter(function (_ref4) {\n      var v = _ref4[1];\n      return Object.keys(v).length === 0;\n    }).forEach(function (_ref5) {\n      var k = _ref5[0];\n      return delete json.selector[k];\n    }); // primary swap\n\n    if (primPath !== '_id' && json.selector[primPath]) {\n      // selector\n      json.selector._id = json.selector[primPath];\n      delete json.selector[primPath];\n    } // if no selector is used, pouchdb has a bug, so we add a default-selector\n\n\n    if (Object.keys(json.selector).length === 0) {\n      json.selector = {\n        _id: {}\n      };\n    }\n\n    this._toJSON = json;\n    return this._toJSON;\n  };\n  /**\n   * get the key-compression version of this query\n   * @return {{selector: {}, sort: []}} compressedQuery\n   */\n\n\n  _proto.keyCompress = function keyCompress() {\n    if (!this.collection.schema.doKeyCompression()) {\n      return this.toJSON();\n    } else {\n      if (!this._keyCompress) {\n        this._keyCompress = this.collection._keyCompressor.compressQuery(this.toJSON());\n      }\n\n      return this._keyCompress;\n    }\n  };\n  /**\n   * deletes all found documents\n   * @return {Promise(RxDocument|RxDocument[])} promise with deleted documents\n   */\n\n\n  _proto.remove = function remove() {\n    var ret;\n    return this.exec().then(function (docs) {\n      ret = docs;\n      if (Array.isArray(docs)) return Promise.all(docs.map(function (doc) {\n        return doc.remove();\n      }));else return docs.remove();\n    }).then(function () {\n      return ret;\n    });\n  };\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optinal)\n   * @param  {object} updateObj\n   * @return {Promise(RxDocument|RxDocument[])} promise with updated documents\n   */\n\n\n  _proto.update = function update() {\n    throw RxError.pluginMissing('update');\n  };\n  /**\n   * regex cannot run on primary _id\n   * @link https://docs.cloudant.com/cloudant_query.html#creating-selector-expressions\n   */\n\n\n  _proto.regex = function regex(params) {\n    var clonedThis = this._clone();\n\n    if (this.mquery._path === this.collection.schema.primaryPath) {\n      throw RxError.newRxError('QU4', {\n        path: this.mquery._path\n      });\n    }\n\n    clonedThis.mquery.regex(params);\n    return _tunnelQueryCache(clonedThis);\n  };\n  /**\n   * make sure it searches index because of pouchdb-find bug\n   * @link https://github.com/nolanlawson/pouchdb-find/issues/204\n   */\n\n\n  _proto.sort = function sort(params) {\n    var clonedThis = this._clone(); // workarround because sort wont work on unused keys\n\n\n    if (typeof params !== 'object') {\n      var checkParam = params.charAt(0) === '-' ? params.substring(1) : params;\n      if (!clonedThis.mquery._conditions[checkParam]) _sortAddToIndex(checkParam, clonedThis);\n    } else {\n      Object.keys(params).filter(function (k) {\n        return !clonedThis.mquery._conditions[k] || !clonedThis.mquery._conditions[k].$gt;\n      }).forEach(function (k) {\n        return _sortAddToIndex(k, clonedThis);\n      });\n    }\n\n    clonedThis.mquery.sort(params);\n    return _tunnelQueryCache(clonedThis);\n  };\n\n  _proto.limit = function limit(amount) {\n    if (this.op === 'findOne') throw RxError.newRxError('QU6');else {\n      var clonedThis = this._clone();\n\n      clonedThis.mquery.limit(amount);\n      return _tunnelQueryCache(clonedThis);\n    }\n  };\n\n  _createClass(RxQuery, [{\n    key: \"$\",\n    get: function get() {\n      var _this2 = this;\n\n      if (!this._$) {\n        /**\n         * We use _resultsDocs$ to emit new results\n         * This also ensure that there is a reemit on subscribe\n         */\n        var results$ = this._resultsDocs$.pipe(mergeMap(function (docs) {\n          return _ensureEqual(_this2).then(function (hasChanged) {\n            if (hasChanged) return false; // wait for next emit\n            else return docs;\n          });\n        }), filter(function (docs) {\n          return !!docs;\n        }), // not if previous returned false\n        map(function (docs) {\n          // findOne()-queries emit document or null\n          if (_this2.op === 'findOne') {\n            var doc = docs.length === 0 ? null : docs[0];\n            return doc;\n          } else return docs; // find()-queries emit RxDocument[]\n\n        }), map(function (docs) {\n          // copy the array so it wont matter if the user modifies it\n          var ret = Array.isArray(docs) ? docs.slice() : docs;\n          return ret;\n        })).asObservable();\n        /**\n         * subscribe to the changeEvent-stream so it detects changed if it has subscribers\n         */\n\n\n        var changeEvents$ = this.collection.docChanges$.pipe(tap(function () {\n          return _ensureEqual(_this2);\n        }), filter(function () {\n          return false;\n        }));\n        this._$ = merge(results$, changeEvents$);\n      }\n\n      return this._$;\n    }\n  }]);\n\n  return RxQuery;\n}();\n\nfunction _getDefaultQuery(collection) {\n  var _ref6;\n\n  return _ref6 = {}, _ref6[collection.schema.primaryPath] = {}, _ref6;\n}\n/**\n * run this query through the QueryCache\n * @return {RxQuery} can be this or another query with the equal state\n */\n\n\nfunction _tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\n/**\n * tunnel the proto-functions of mquery to RxQuery\n * @param  {any} rxQueryProto    [description]\n * @param  {string[]} mQueryProtoKeys [description]\n * @return {void}                 [description]\n */\n\n\nfunction protoMerge(rxQueryProto, mQueryProtoKeys) {\n  mQueryProtoKeys.filter(function (attrName) {\n    return !attrName.startsWith('_');\n  }).filter(function (attrName) {\n    return !rxQueryProto[attrName];\n  }).forEach(function (attrName) {\n    rxQueryProto[attrName] = function (p1) {\n      var clonedThis = this._clone();\n\n      clonedThis.mquery[attrName](p1);\n      return _tunnelQueryCache(clonedThis);\n    };\n  });\n}\n\nvar protoMerged = false;\nexport function create(op, queryObj, collection) {\n  // checks\n  if (queryObj && typeof queryObj !== 'object') {\n    throw RxError.newRxTypeError('QU7', {\n      queryObj: queryObj\n    });\n  }\n\n  if (Array.isArray(queryObj)) {\n    throw RxError.newRxTypeError('QU8', {\n      queryObj: queryObj\n    });\n  }\n\n  var ret = new RxQuery(op, queryObj, collection); // ensure when created with same params, only one is created\n\n  ret = _tunnelQueryCache(ret);\n\n  if (!protoMerged) {\n    protoMerged = true;\n    protoMerge(Object.getPrototypeOf(ret), Object.getOwnPropertyNames(ret.mquery.__proto__));\n  }\n\n  runPluginHooks('createRxQuery', ret);\n  return ret;\n}\n/**\n * throws an error that says that the key is not in the schema\n */\n\nfunction _throwNotInSchema(key) {\n  throw RxError.newRxError('QU5', {\n    key: key\n  });\n}\n/**\n * adds the field of 'sort' to the search-index\n * @link https://github.com/nolanlawson/pouchdb-find/issues/204\n */\n\n\nfunction _sortAddToIndex(checkParam, clonedThis) {\n  var schemaObj = clonedThis.collection.schema.getSchemaByObjectPath(checkParam);\n  if (!schemaObj) _throwNotInSchema(checkParam);\n\n  switch (schemaObj.type) {\n    case 'integer':\n      // TODO change back to -Infinity when issue resolved\n      // @link https://github.com/pouchdb/pouchdb/issues/6454\n      clonedThis.mquery.where(checkParam).gt(-9999999999999999999999999999); // -Infinity does not work since pouchdb 6.2.0\n\n      break;\n\n    case 'string':\n      /**\n       * strings need an empty string, see\n       * @link https://github.com/pubkey/rxdb/issues/585\n       */\n      clonedThis.mquery.where(checkParam).gt('');\n      break;\n\n    default:\n      clonedThis.mquery.where(checkParam).gt(null);\n      break;\n  }\n}\n/**\n * check if the current results-state is in sync with the database\n * @return {Boolean} false if not which means it should re-execute\n */\n\n\nfunction _isResultsInSync(rxQuery) {\n  if (rxQuery._latestChangeEvent >= rxQuery.collection._changeEventBuffer.counter) return true;else return false;\n}\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n */\n\n\nfunction _ensureEqual(rxQuery) {\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(function () {\n    return new Promise(function (res) {\n      return setTimeout(res, 0);\n    });\n  }).then(function () {\n    return __ensureEqual(rxQuery);\n  }).then(function (ret) {\n    return new Promise(function (res) {\n      return setTimeout(res, 0);\n    }).then(function () {\n      return ret;\n    });\n  });\n  return rxQuery._ensureEqualQueue;\n}\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return {Promise<boolean>|boolean} true if results have changed\n */\n\n\nfunction __ensureEqual(rxQuery) {\n  if (rxQuery.collection.database.destroyed) return false; // db is closed\n\n  if (_isResultsInSync(rxQuery)) return false; // nothing happend\n\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n\n  if (rxQuery._latestChangeEvent === -1) mustReExec = true; // have not executed yet -> must run\n\n  /**\n   * try to use the queryChangeDetector to calculate the new results\n   */\n\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.counter;\n\n      var runChangeEvents = rxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n\n      var changeResult = rxQuery._queryChangeDetector.runChangeDetection(runChangeEvents);\n\n      if (!Array.isArray(changeResult) && changeResult) {\n        // could not calculate the new results, execute must be done\n        mustReExec = true;\n      }\n\n      if (Array.isArray(changeResult) && !deepEqual(changeResult, rxQuery._resultsData)) {\n        // we got the new results, we do not have to re-execute, mustReExec stays false\n        ret = true; // true because results changed\n\n        rxQuery._setResultData(changeResult);\n      }\n    }\n  } // oh no we have to re-execute the whole query over the database\n\n\n  if (mustReExec) {\n    // counter can change while _execOverDatabase() is running so we save it here\n    var latestAfter = rxQuery.collection._changeEventBuffer.counter;\n    return rxQuery._execOverDatabase().then(function (newResultData) {\n      rxQuery._latestChangeEvent = latestAfter;\n\n      if (!deepEqual(newResultData, rxQuery._resultsData)) {\n        ret = true; // true because results changed\n\n        rxQuery._setResultData(newResultData);\n      }\n\n      return ret;\n    });\n  }\n\n  return ret; // true if results have changed\n}\n\nexport function isInstanceOf(obj) {\n  return obj instanceof RxQuery;\n}\nexport default {\n  create: create,\n  RxQuery: RxQuery,\n  isInstanceOf: isInstanceOf\n};","map":null,"metadata":{},"sourceType":"module"}
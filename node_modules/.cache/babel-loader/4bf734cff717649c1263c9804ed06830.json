{"ast":null,"code":"/*import getDb from '../../db';\nimport md5 from 'md5';\nimport { normalize, schema } from 'normalizr';\n\n\n\nasync function storeEvents(events){\n  const db = await getDb();\n  const dbEvents = filter(events);\n  const addEvents = [];\n  //need to preprocess data\n  const results = dbEvents.map(async dbEvent => {\n    if(!!dbEvent.id) {\n      try {\n        await db.events.upsert(dbEvent);\n      } catch(e) {\n        console.log(e);\n      }\n      return dbEvent;\n    }\n  });\n  let values = await Promise.all(results);\n  return values;\n}\n\nasync function retrieveEvents() {\n  const db = await getDb();\n  let data = [];\n  await db.events.find().exec().then(events => {\n      data = events.map(singleEvent => {\n        return {\n          'id' : md5(singleEvent.id),\n          'end' : singleEvent.end,\n          'start': singleEvent.start,\n          'summary': singleEvent.summary,\n          'organizer': singleEvent.organizer,\n          'recurrence': singleEvent.recurrence,\n          'iCalUID': singleEvent.iCalUID,\n          'attendees': singleEvent.attendees\n        }\n      });\n  });\n  return data;\n}\n/*export const storeEventsMiddleware = store => next => action => {\n  if(action.type === 'BEGIN_STORE_EVENTS') {\n    storeEvents(action.payload).then((resp) => {\n      next({\n        type: 'SUCCESS_STORED_EVENTS',\n        payload: resp\n      })\n    }, (error) => {\n      console.log(error);\n    })\n  }\n  return next(action);\n}*/\n\n/*export const apiSuccessToDbMiddleware = store => next => action => {\n  if(action.type === 'POST_EVENT_SUCCESS') {\n    next({\n      type: 'BEGIN_STORE_EVENTS',\n      payload: action.payload\n    })\n  }\n  if(action.type === 'GET_EVENTS_SUCCESS') {\n    next({\n      type: 'BEGIN_STORE_EVENTS',\n      payload: action.payload\n    })\n  }\n  return next(action);\n}\n\n/*export const eventsStoreOutMiddleware = store => next => action => {\n  if(action.type === 'RETRIEVE_STORED_EVENTS') {\n    retrieveEvents().then((resp) => {\n      next({\n        type: 'UPDATE_STORED_EVENTS',\n        payload: resp\n      })\n    });\n  }\n  return next(action);\n}\n\nconst filter = (events) => {\n  if(events.data.length > 0) {\n    const formated_events = events.data\n    .map(eachEvent => {\n        return  ({\n          'id' : md5(eachEvent.id),\n          'end' : eachEvent.end,\n          'start': eachEvent.start,\n          'summary': eachEvent.summary,\n          'organizer': eachEvent.organizer,\n          'recurrence': eachEvent.recurrence,\n          'iCalUID': eachEvent.iCalUID,\n          'attendees': eachEvent.attendees\n        })\n      }\n    );\n    return formated_events;\n  }\n  else {\n    return [];\n  }\n}*/","map":{"version":3,"sources":["/Users/sham/big-calendar/src/middleware/db/events.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0DA","sourcesContent":["/*import getDb from '../../db';\nimport md5 from 'md5';\nimport { normalize, schema } from 'normalizr';\n\n\n\nasync function storeEvents(events){\n  const db = await getDb();\n  const dbEvents = filter(events);\n  const addEvents = [];\n  //need to preprocess data\n  const results = dbEvents.map(async dbEvent => {\n    if(!!dbEvent.id) {\n      try {\n        await db.events.upsert(dbEvent);\n      } catch(e) {\n        console.log(e);\n      }\n      return dbEvent;\n    }\n  });\n  let values = await Promise.all(results);\n  return values;\n}\n\nasync function retrieveEvents() {\n  const db = await getDb();\n  let data = [];\n  await db.events.find().exec().then(events => {\n      data = events.map(singleEvent => {\n        return {\n          'id' : md5(singleEvent.id),\n          'end' : singleEvent.end,\n          'start': singleEvent.start,\n          'summary': singleEvent.summary,\n          'organizer': singleEvent.organizer,\n          'recurrence': singleEvent.recurrence,\n          'iCalUID': singleEvent.iCalUID,\n          'attendees': singleEvent.attendees\n        }\n      });\n  });\n  return data;\n}\n/*export const storeEventsMiddleware = store => next => action => {\n  if(action.type === 'BEGIN_STORE_EVENTS') {\n    storeEvents(action.payload).then((resp) => {\n      next({\n        type: 'SUCCESS_STORED_EVENTS',\n        payload: resp\n      })\n    }, (error) => {\n      console.log(error);\n    })\n  }\n  return next(action);\n}*/\n\n/*export const apiSuccessToDbMiddleware = store => next => action => {\n  if(action.type === 'POST_EVENT_SUCCESS') {\n    next({\n      type: 'BEGIN_STORE_EVENTS',\n      payload: action.payload\n    })\n  }\n  if(action.type === 'GET_EVENTS_SUCCESS') {\n    next({\n      type: 'BEGIN_STORE_EVENTS',\n      payload: action.payload\n    })\n  }\n  return next(action);\n}\n\n/*export const eventsStoreOutMiddleware = store => next => action => {\n  if(action.type === 'RETRIEVE_STORED_EVENTS') {\n    retrieveEvents().then((resp) => {\n      next({\n        type: 'UPDATE_STORED_EVENTS',\n        payload: resp\n      })\n    });\n  }\n  return next(action);\n}\n\nconst filter = (events) => {\n  if(events.data.length > 0) {\n    const formated_events = events.data\n    .map(eachEvent => {\n        return  ({\n          'id' : md5(eachEvent.id),\n          'end' : eachEvent.end,\n          'start': eachEvent.start,\n          'summary': eachEvent.summary,\n          'organizer': eachEvent.organizer,\n          'recurrence': eachEvent.recurrence,\n          'iCalUID': eachEvent.iCalUID,\n          'attendees': eachEvent.attendees\n        })\n      }\n    );\n    return formated_events;\n  }\n  else {\n    return [];\n  }\n}*/\n"]},"metadata":{},"sourceType":"module"}
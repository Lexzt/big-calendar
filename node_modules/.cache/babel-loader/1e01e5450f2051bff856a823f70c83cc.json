{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n\nimport PouchDB from './pouch-db';\nimport { clone } from './util';\nimport RxSchema from './rx-schema';\nimport Crypter from './crypter';\nimport RxError from './rx-error';\nimport overwritable from './overwritable';\nimport hooks from './hooks';\nimport { Subject } from 'rxjs';\n\nvar DataMigrator =\n/*#__PURE__*/\nfunction () {\n  function DataMigrator(newestCollection, migrationStrategies) {\n    this.newestCollection = newestCollection;\n    this.migrationStrategies = migrationStrategies;\n    this.currentSchema = newestCollection.schema;\n    this.database = newestCollection.database;\n    this.name = newestCollection.name;\n  }\n  /**\n   * @param {number} [batchSize=10] amount of documents handled in parallel\n   * @return {Observable} emits the migration-state\n   */\n\n\n  var _proto = DataMigrator.prototype;\n\n  _proto.migrate = function migrate() {\n    var _this = this;\n\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    if (this._migrated) throw RxError.newRxError('DM1');\n    this._migrated = true;\n    var state = {\n      done: false,\n      // true if finished\n      total: null,\n      // will be the doc-count\n      handled: 0,\n      // amount of handled docs\n      success: 0,\n      // handled docs which successed\n      deleted: 0,\n      // handled docs which got deleted\n      percent: 0 // percentage\n\n    };\n    var observer = new Subject();\n    /**\n     * TODO this is a side-effect which might throw\n     * We did this because it is not possible to create new Observer(async(...))\n     * @link https://github.com/ReactiveX/rxjs/issues/4074\n     */\n\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var oldCols, countAll, totalCount, currentCol, _loop;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _getOldCollections(_this);\n\n            case 2:\n              oldCols = _context2.sent;\n              _context2.next = 5;\n              return Promise.all(oldCols.map(function (oldCol) {\n                return oldCol.countAllUndeleted();\n              }));\n\n            case 5:\n              countAll = _context2.sent;\n              totalCount = countAll.reduce(function (cur, prev) {\n                return prev = cur + prev;\n              }, 0);\n              state.total = totalCount;\n              observer.next(clone(state));\n              currentCol = oldCols.shift();\n              _loop =\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _loop() {\n                var migrationState$;\n                return _regeneratorRuntime.wrap(function _loop$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        migrationState$ = currentCol.migrate(batchSize);\n                        _context.next = 3;\n                        return new Promise(function (res) {\n                          var sub = migrationState$.subscribe(function (subState) {\n                            state.handled++;\n                            state[subState.type] = state[subState.type] + 1;\n                            state.percent = Math.round(state.handled / state.total * 100);\n                            observer.next(clone(state));\n                          }, function (e) {\n                            sub.unsubscribe();\n                            observer.error(e);\n                          }, function () {\n                            sub.unsubscribe();\n                            res();\n                          });\n                        });\n\n                      case 3:\n                        currentCol = oldCols.shift();\n\n                      case 4:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _loop, this);\n              });\n\n            case 11:\n              if (!currentCol) {\n                _context2.next = 15;\n                break;\n              }\n\n              return _context2.delegateYield(_loop(), \"t0\", 13);\n\n            case 13:\n              _context2.next = 11;\n              break;\n\n            case 15:\n              state.done = true;\n              state.percent = 100;\n              observer.next(clone(state));\n              observer.complete();\n\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee, this);\n    }))();\n\n    return observer.asObservable();\n  };\n\n  _proto.migratePromise =\n  /*#__PURE__*/\n  function () {\n    var _migratePromise = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(batchSize) {\n      var _this2 = this;\n\n      var must;\n      return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this._migratePromise) {\n                _context3.next = 7;\n                break;\n              }\n\n              _context3.next = 3;\n              return mustMigrate(this);\n\n            case 3:\n              must = _context3.sent;\n\n              if (must) {\n                _context3.next = 6;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", Promise.resolve(false));\n\n            case 6:\n              this._migratePromise = new Promise(function (res, rej) {\n                var state$ = _this2.migrate(batchSize);\n\n                state$.subscribe(null, rej, res);\n              });\n\n            case 7:\n              return _context3.abrupt(\"return\", this._migratePromise);\n\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    return function migratePromise(_x) {\n      return _migratePromise.apply(this, arguments);\n    };\n  }();\n\n  return DataMigrator;\n}();\n\nvar OldCollection =\n/*#__PURE__*/\nfunction () {\n  function OldCollection(version, schemaObj, dataMigrator) {\n    this.version = version;\n    this.dataMigrator = dataMigrator;\n    this.schemaObj = schemaObj;\n    this.newestCollection = dataMigrator.newestCollection;\n    this.database = dataMigrator.newestCollection.database;\n  }\n\n  var _proto2 = OldCollection.prototype;\n  /**\n   * @return {Promise}\n   */\n\n  _proto2.countAllUndeleted = function countAllUndeleted() {\n    return PouchDB.countAllUndeleted(this.pouchdb);\n  };\n\n  _proto2.getBatch = function getBatch(batchSize) {\n    var _this3 = this;\n\n    return PouchDB.getBatch(this.pouchdb, batchSize).then(function (docs) {\n      return docs.map(function (doc) {\n        return _this3._handleFromPouch(doc);\n      });\n    });\n  };\n  /**\n   * handles a document from the pouchdb-instance\n   */\n\n\n  _proto2._handleFromPouch = function _handleFromPouch(docData) {\n    var data = clone(docData);\n    data = this.schema.swapIdToPrimary(docData);\n    if (this.schema.doKeyCompression()) data = this.keyCompressor.decompress(data);\n    data = this.crypter.decrypt(data);\n    return data;\n  };\n  /**\n   * wrappers for Pouch.put/get to handle keycompression etc\n   */\n\n\n  _proto2._handleToPouch = function _handleToPouch(docData) {\n    var data = clone(docData);\n    data = this.crypter.encrypt(data);\n    data = this.schema.swapPrimaryToId(data);\n    if (this.schema.doKeyCompression()) data = this.keyCompressor.compress(data);\n    return data;\n  };\n  /**\n   * runs the doc-data through all following migrationStrategies\n   * so it will match the newest schema.\n   * @throws Error if final doc does not match final schema or migrationStrategy crashes\n   * @return {Object|null} final object or null if migrationStrategy deleted it\n   */\n\n\n  _proto2.migrateDocumentData =\n  /*#__PURE__*/\n  function () {\n    var _migrateDocumentData = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(doc) {\n      var nextVersion;\n      return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              doc = clone(doc);\n              nextVersion = this.version + 1;\n            // run throught migrationStrategies\n\n            case 2:\n              if (!(nextVersion <= this.newestCollection.schema.version)) {\n                _context4.next = 11;\n                break;\n              }\n\n              _context4.next = 5;\n              return this.dataMigrator.migrationStrategies[nextVersion + ''](doc);\n\n            case 5:\n              doc = _context4.sent;\n              nextVersion++;\n\n              if (!(doc === null)) {\n                _context4.next = 9;\n                break;\n              }\n\n              return _context4.abrupt(\"return\", null);\n\n            case 9:\n              _context4.next = 2;\n              break;\n\n            case 11:\n              _context4.prev = 11;\n              this.newestCollection.schema.validate(doc);\n              _context4.next = 18;\n              break;\n\n            case 15:\n              _context4.prev = 15;\n              _context4.t0 = _context4[\"catch\"](11);\n              throw RxError.newRxError('DM2', {\n                fromVersion: this.version,\n                toVersion: this.newestCollection.schema.version,\n                finalDoc: doc\n              });\n\n            case 18:\n              return _context4.abrupt(\"return\", doc);\n\n            case 19:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee3, this, [[11, 15]]);\n    }));\n\n    return function migrateDocumentData(_x2) {\n      return _migrateDocumentData.apply(this, arguments);\n    };\n  }();\n  /**\n   * transform docdata and save to new collection\n   * @return {{type: string, doc: {}}} status-action with status and migrated document\n   */\n\n\n  _proto2._migrateDocument =\n  /*#__PURE__*/\n  function () {\n    var _migrateDocument2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(doc) {\n      var migrated, action, res;\n      return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this.migrateDocumentData(doc);\n\n            case 2:\n              migrated = _context5.sent;\n              action = {\n                doc: doc,\n                migrated: migrated,\n                oldCollection: this,\n                newestCollection: this.newestCollection\n              };\n\n              if (!migrated) {\n                _context5.next = 16;\n                break;\n              }\n\n              hooks.runPluginHooks('preMigrateDocument', action); // save to newest collection\n\n              delete migrated._rev;\n              _context5.next = 9;\n              return this.newestCollection._pouchPut(migrated, true);\n\n            case 9:\n              res = _context5.sent;\n              action.res = res;\n              action.type = 'success';\n              _context5.next = 14;\n              return hooks.runAsyncPluginHooks('postMigrateDocument', action);\n\n            case 14:\n              _context5.next = 17;\n              break;\n\n            case 16:\n              action.type = 'deleted';\n\n            case 17:\n              _context5.prev = 17;\n              _context5.next = 20;\n              return this.pouchdb.remove(this._handleToPouch(doc));\n\n            case 20:\n              _context5.next = 24;\n              break;\n\n            case 22:\n              _context5.prev = 22;\n              _context5.t0 = _context5[\"catch\"](17);\n\n            case 24:\n              return _context5.abrupt(\"return\", action);\n\n            case 25:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee4, this, [[17, 22]]);\n    }));\n\n    return function _migrateDocument(_x3) {\n      return _migrateDocument2.apply(this, arguments);\n    };\n  }();\n  /**\n   * deletes this.pouchdb and removes it from the database.collectionsCollection\n   * @return {Promise}\n   */\n\n\n  _proto2[\"delete\"] = function _delete() {\n    var _this4 = this;\n\n    return this.pouchdb.destroy().then(function () {\n      return _this4.database.removeCollectionDoc(_this4.dataMigrator.name, _this4.schema);\n    });\n  };\n  /**\n   * runs the migration on all documents and deletes the pouchdb afterwards\n   */\n\n\n  _proto2.migrate = function migrate() {\n    var _this5 = this;\n\n    var batchSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    if (this._migrate) throw RxError.newRxError('DM3');\n    this._migrate = true;\n    var observer = new Subject();\n    /**\n     * TODO this is a side-effect which might throw\n     * @see DataMigrator.migrate()\n     */\n\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5() {\n      var batch, error;\n      return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return _this5.getBatch(batchSize);\n\n            case 2:\n              batch = _context6.sent;\n\n            case 3:\n              _context6.next = 5;\n              return Promise.all(batch.map(function (doc) {\n                return _this5._migrateDocument(doc).then(function (action) {\n                  return observer.next(action);\n                });\n              }))[\"catch\"](function (e) {\n                return error = e;\n              });\n\n            case 5:\n              if (!error) {\n                _context6.next = 8;\n                break;\n              }\n\n              observer.error(error);\n              return _context6.abrupt(\"return\");\n\n            case 8:\n              _context6.next = 10;\n              return _this5.getBatch(batchSize);\n\n            case 10:\n              batch = _context6.sent;\n\n            case 11:\n              if (!error && batch.length > 0) {\n                _context6.next = 3;\n                break;\n              }\n\n            case 12:\n              _context6.next = 14;\n              return _this5[\"delete\"]();\n\n            case 14:\n              observer.complete();\n\n            case 15:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee5, this);\n    }))();\n\n    return observer.asObservable();\n  };\n\n  _proto2.migratePromise = function migratePromise(batchSize) {\n    var _this6 = this;\n\n    if (!this._migratePromise) {\n      this._migratePromise = new Promise(function (res, rej) {\n        var state$ = _this6.migrate(batchSize);\n\n        state$.subscribe(null, rej, res);\n      });\n    }\n\n    return this._migratePromise;\n  };\n\n  _createClass(OldCollection, [{\n    key: \"schema\",\n    get: function get() {\n      if (!this._schema) {\n        //            delete this.schemaObj._id;\n        this._schema = RxSchema.create(this.schemaObj, false);\n      }\n\n      return this._schema;\n    }\n  }, {\n    key: \"keyCompressor\",\n    get: function get() {\n      if (!this._keyCompressor) this._keyCompressor = overwritable.createKeyCompressor(this.schema);\n      return this._keyCompressor;\n    }\n  }, {\n    key: \"crypter\",\n    get: function get() {\n      if (!this._crypter) this._crypter = Crypter.create(this.database.password, this.schema);\n      return this._crypter;\n    }\n  }, {\n    key: \"pouchdb\",\n    get: function get() {\n      if (!this._pouchdb) {\n        this._pouchdb = this.database._spawnPouchDB(this.newestCollection.name, this.version, this.newestCollection.pouchSettings);\n      }\n\n      return this._pouchdb;\n    }\n  }]);\n\n  return OldCollection;\n}();\n/**\n * get an array with OldCollection-instances from all existing old pouchdb-instance\n * @return {Promise<OldCollection[]>}\n */\n\n\nexport function _getOldCollections(dataMigrator) {\n  return Promise.all(dataMigrator.currentSchema.previousVersions.map(function (v) {\n    return dataMigrator.database._collectionsPouch.get(dataMigrator.name + '-' + v);\n  }).map(function (fun) {\n    return fun[\"catch\"](function () {\n      return null;\n    });\n  }) // auto-catch so Promise.all continues\n  ).then(function (oldColDocs) {\n    return oldColDocs.filter(function (colDoc) {\n      return colDoc !== null;\n    }).map(function (colDoc) {\n      return new OldCollection(colDoc.schema.version, colDoc.schema, dataMigrator);\n    });\n  });\n}\n/**\n * returns true if a migration is needed\n * @return {Promise<boolean>}\n */\n\nexport function mustMigrate(dataMigrator) {\n  if (dataMigrator.currentSchema.version === 0) return Promise.resolve(false);\n  return _getOldCollections(dataMigrator).then(function (oldCols) {\n    if (oldCols.length === 0) return false;else return true;\n  });\n}\nexport function create(newestCollection, migrationStrategies) {\n  return new DataMigrator(newestCollection, migrationStrategies);\n}\nexport default {\n  create: create\n};","map":null,"metadata":{},"sourceType":"module"}
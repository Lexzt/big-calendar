{"ast":null,"code":"/**\n * a buffer-cache which holds the last X changeEvents of the collection\n * TODO this could be optimized to only store the last event of one document\n */\nvar ChangeEventBuffer =\n/*#__PURE__*/\nfunction () {\n  function ChangeEventBuffer(collection) {\n    var _this = this;\n\n    this.collection = collection;\n    this.subs = [];\n    this.limit = 100;\n    /**\n     * array with changeEvents\n     * starts with oldest known event, ends with newest\n     * @type {RxChangeEvent[]}\n     */\n\n    this.buffer = [];\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.subs.push(this.collection.$.subscribe(function (cE) {\n      return _this._handleChangeEvent(cE);\n    }));\n  }\n\n  var _proto = ChangeEventBuffer.prototype;\n\n  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {\n    // console.log('changeEventBuffer()._handleChangeEvent()');\n    this.counter++;\n    this.buffer.push(changeEvent);\n    this.eventCounterMap.set(changeEvent, this.counter);\n\n    while (this.buffer.length > this.limit) {\n      this.buffer.shift();\n    }\n  };\n  /**\n   * gets the array-index for the given pointer\n   * @param  {number} pointer\n   * @return {number|null} arrayIndex which can be used to itterate from there. If null, pointer is out of lower bound\n   */\n\n\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  };\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @param  {number} pointer\n   * @return {RxChangeEvent[]|null} array with change-events. Iif null, pointer out of bounds\n   */\n\n\n  _proto.getFrom = function getFrom(pointer) {\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null) // out of bounds\n      return null;\n\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) return ret;else ret.push(nextEvent);\n    }\n  };\n\n  _proto.runFrom = function runFrom(pointer, fn) {\n    this.getFrom(pointer).forEach(function (cE) {\n      return fn(cE);\n    });\n  };\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc\n   * @param {ChangeEvent[]} changeEvents\n   * @return {ChangeEvents[]}\n   */\n\n\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    var docEventMap = {};\n    changeEvents.forEach(function (changeEvent) {\n      docEventMap[changeEvent.data.doc] = changeEvent;\n    });\n    return Object.values(docEventMap);\n  };\n  /**\n   * use this to check if a change has already been handled\n   * @param {string} revision \n   * @returns {boolean} true if change with revision exists\n   * \n   */\n\n\n  _proto.hasChangeWithRevision = function hasChangeWithRevision(revision) {\n    // we loop from behind because its more likely that the searched event is at the end\n    var t = this.buffer.length;\n\n    while (t > 0) {\n      t--;\n      var cE = this.buffer[t];\n      if (cE.data.v && cE.data.v._rev === revision) return true;\n    }\n\n    return false;\n  };\n\n  _proto.destroy = function destroy() {\n    this.subs.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n  };\n\n  return ChangeEventBuffer;\n}();\n\nexport function create(collection) {\n  return new ChangeEventBuffer(collection);\n}\nexport default {\n  create: create\n};","map":null,"metadata":{},"sourceType":"module"}
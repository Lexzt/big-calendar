{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * @module BatchRequestContent\r\n */\n\nvar RequestMethod_1 = require(\"../RequestMethod\");\n/**\r\n * Class for handling BatchRequestContent\r\n */\n\n\nvar BatchRequestContent =\n/** @class */\nfunction () {\n  /**\r\n   * Constructs a BatchRequestContent instance\r\n   * @param {BatchRequestStep[]} [requests] - Array of requests value\r\n   */\n  function BatchRequestContent(requests) {\n    var self = this;\n    self.requests = new Map();\n\n    if (typeof requests !== \"undefined\") {\n      var limit = BatchRequestContent.requestLimit;\n\n      if (requests.length > limit) {\n        var error = new Error(\"Maximum requests limit exceeded, Max allowed number of requests are \" + limit);\n        error.name = \"Limit Exceeded Error\";\n        throw error;\n      }\n\n      for (var _i = 0, requests_1 = requests; _i < requests_1.length; _i++) {\n        var req = requests_1[_i];\n        self.addRequest(req);\n      }\n    }\n  }\n  /**\r\n   * Adds a request to the batch request content\r\n   * @param {BatchRequestStep} request - The request value\r\n   * @return The id of the added request\r\n   */\n\n\n  BatchRequestContent.prototype.addRequest = function (request) {\n    var self = this,\n        limit = BatchRequestContent.requestLimit;\n\n    if (request.id === \"\") {\n      var error = new Error(\"Id for a request is empty, Please provide an unique id\");\n      error.name = \"Empty Id For Request\";\n      throw error;\n    }\n\n    if (self.requests.size === limit) {\n      var error = new Error(\"Maximum requests limit exceeded, Max allowed number of requests are \" + limit);\n      error.name = \"Limit Exceeded Error\";\n      throw error;\n    }\n\n    if (self.requests.has(request.id)) {\n      var error = new Error(\"Adding request with duplicate id \" + request.id + \", Make the id of the requests unique\");\n      error.name = \"Duplicate RequestId Error\";\n      throw error;\n    }\n\n    self.requests.set(request.id, request);\n    return request.id;\n  };\n  /**\r\n   * Removes request from the batch payload and its dependencies from all dependents\r\n   * @param {string} requestId - The id of a request that needs to be removed\r\n   * @return The boolean indicating removed status\r\n   */\n\n\n  BatchRequestContent.prototype.removeRequest = function (requestId) {\n    var self = this,\n        deleteStatus = self.requests.delete(requestId),\n        iterator = self.requests.entries(),\n        cur = iterator.next();\n    /**\r\n     * Removing dependencies where this request is present as a dependency\r\n     */\n\n    while (!cur.done) {\n      var dependencies = cur.value[1].dependsOn;\n\n      if (typeof dependencies !== \"undefined\") {\n        var index = dependencies.indexOf(requestId);\n\n        if (index !== -1) {\n          dependencies.splice(index, 1);\n        }\n\n        if (dependencies.length === 0) {\n          delete cur.value[1].dependsOn;\n        }\n      }\n\n      cur = iterator.next();\n    }\n\n    return deleteStatus;\n  };\n  /**\r\n   * @async\r\n   * Serialize content from BatchRequestContent instance\r\n   * @return The body content to make batch request\r\n   */\n\n\n  BatchRequestContent.prototype.getContent = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var self, requestBody, requests, iterator, cur, error, error, requestStep, batchRequestData, error;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            self = this, requestBody = {}, requests = [], iterator = self.requests.entries(), cur = iterator.next();\n\n            if (cur.done) {\n              error = new Error(\"No requests added yet, Please add at least one request.\");\n              error.name = \"Empty Payload\";\n              throw error;\n            }\n\n            if (!BatchRequestContent.validateDependencies(self.requests)) {\n              error = new Error(\"Invalid dependency found, Dependency should be:\\n1. Parallel - no individual request states a dependency in the dependsOn property.\\n2. Serial - all individual requests depend on the previous individual request.\\n3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.\");\n              error.name = \"Invalid Dependency\";\n              throw error;\n            }\n\n            _a.label = 1;\n\n          case 1:\n            if (!!cur.done) return [3\n            /*break*/\n            , 3];\n            requestStep = cur.value[1];\n            return [4\n            /*yield*/\n            , BatchRequestContent.getRequestData(requestStep.request)];\n\n          case 2:\n            batchRequestData = _a.sent();\n            /**\r\n             * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/json_batching#request-format}\r\n             */\n\n            if (batchRequestData.body !== undefined && (batchRequestData.headers === undefined || batchRequestData.headers[\"content-type\"] === undefined)) {\n              error = new Error(\"Content-type header is not mentioned for request #\" + requestStep.id + \", For request having body, Content-type header should be mentioned\");\n              error.name = \"Invalid Content-type header\";\n              throw error;\n            }\n\n            batchRequestData.id = requestStep.id;\n\n            if (requestStep.dependsOn !== undefined && requestStep.dependsOn.length > 0) {\n              batchRequestData.dependsOn = requestStep.dependsOn;\n            }\n\n            requests.push(batchRequestData);\n            cur = iterator.next();\n            return [3\n            /*break*/\n            , 1];\n\n          case 3:\n            requestBody.requests = requests;\n            return [2\n            /*return*/\n            , requestBody];\n        }\n      });\n    });\n  };\n  /**\r\n   * @private\r\n   * @static\r\n   * Validates the dependency chain of the requests\r\n   *\r\n   * Note:\r\n   * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:\r\n   * 1. Parallel - no individual request states a dependency in the dependsOn property.\r\n   * 2. Serial - all individual requests depend on the previous individual request.\r\n   * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.\r\n   * As JSON batching matures, these limitations will be removed.\r\n   * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n   *\r\n   * @return The boolean indicating the validation status\r\n   */\n\n\n  BatchRequestContent.validateDependencies = function (requests) {\n    var isParallel = function isParallel(requests) {\n      var iterator = requests.entries(),\n          cur = iterator.next();\n\n      while (!cur.done) {\n        var curReq = cur.value[1];\n\n        if (curReq.dependsOn !== undefined && curReq.dependsOn.length > 0) {\n          return false;\n        }\n\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    var isSerial = function isSerial(requests) {\n      var iterator = requests.entries(),\n          cur = iterator.next();\n      var firstRequest = cur.value[1];\n\n      if (firstRequest.dependsOn !== undefined && firstRequest.dependsOn.length > 0) {\n        return false;\n      }\n\n      var prev = cur;\n      cur = iterator.next();\n\n      while (!cur.done) {\n        var curReq = cur.value[1];\n\n        if (curReq.dependsOn === undefined || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {\n          return false;\n        }\n\n        prev = cur;\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    var isSame = function isSame(requests) {\n      var iterator = requests.entries(),\n          cur = iterator.next();\n      var firstRequest = cur.value[1],\n          dependencyId;\n\n      if (firstRequest.dependsOn === undefined || firstRequest.dependsOn.length === 0) {\n        dependencyId = firstRequest.id;\n      } else {\n        if (firstRequest.dependsOn.length === 1) {\n          var fDependencyId = firstRequest.dependsOn[0];\n\n          if (fDependencyId !== firstRequest.id && requests.has(fDependencyId)) {\n            dependencyId = fDependencyId;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      cur = iterator.next();\n\n      while (!cur.done) {\n        var curReq = cur.value[1];\n\n        if ((curReq.dependsOn === undefined || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {\n          return false;\n        }\n\n        if (curReq.dependsOn !== undefined && curReq.dependsOn.length !== 0) {\n          if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {\n            return false;\n          }\n\n          if (curReq.dependsOn.length > 1) {\n            return false;\n          }\n        }\n\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    if (requests.size === 0) {\n      var error = new Error(\"Empty requests map, Please provide at least one request.\");\n      error.name = \"Empty Requests Error\";\n      throw error;\n    }\n\n    return isParallel(requests) || isSerial(requests) || isSame(requests);\n  };\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * Converts Request Object instance to a JSON\r\n   * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance\r\n   * @return A promise that resolves to JSON representation of a request\r\n   */\n\n\n  BatchRequestContent.getRequestData = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestData, hasHttpRegex, headers, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            requestData = {};\n            hasHttpRegex = new RegExp(\"^https?:\\/\\/\");\n\n            if (hasHttpRegex.test(request.url)) {\n              // Stripping off hostname, port and url scheme\n              requestData.url = \"/\" + request.url.split(/.*?\\/\\/.*?\\//)[1];\n            } else {\n              requestData.url = request.url;\n            }\n\n            requestData.method = request.method;\n            headers = {};\n            request.headers.forEach(function (value, key) {\n              headers[key] = value;\n            });\n\n            if (Object.keys(headers).length) {\n              requestData.headers = headers;\n            }\n\n            if (!(request.method === RequestMethod_1.RequestMethod.PATCH || request.method === RequestMethod_1.RequestMethod.POST || request.method === RequestMethod_1.RequestMethod.PUT)) return [3\n            /*break*/\n            , 2];\n            _a = requestData;\n            return [4\n            /*yield*/\n            , BatchRequestContent.getRequestBody(request)];\n\n          case 1:\n            _a.body = _b.sent();\n            _b.label = 2;\n\n          case 2:\n            /**\r\n             * TODO: Check any other property needs to be used from the Request object and add them\r\n             */\n            return [2\n            /*return*/\n            , requestData];\n        }\n      });\n    });\n  };\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * Gets the body of a Request object instance\r\n   * @param {IsomorphicRequest} request - The IsomorphicRequest object instance\r\n   * @return The Promise that resolves to a body value of a Request\r\n   */\n\n\n  BatchRequestContent.getRequestBody = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var bodyParsed, body, cloneReq, e_1, blob_1, reader_1, buffer, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            bodyParsed = false;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            cloneReq = request.clone();\n            return [4\n            /*yield*/\n            , cloneReq.json()];\n\n          case 2:\n            body = _a.sent();\n            bodyParsed = true;\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (!!bodyParsed) return [3\n            /*break*/\n            , 12];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 11,, 12]);\n\n            if (!(typeof Blob !== \"undefined\")) return [3\n            /*break*/\n            , 8];\n            return [4\n            /*yield*/\n            , request.blob()];\n\n          case 6:\n            blob_1 = _a.sent();\n            reader_1 = new FileReader();\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              reader_1.addEventListener(\"load\", function () {\n                var dataURL = reader_1.result,\n\n                /**\r\n                 * Some valid dataURL schemes:\r\n                 *  1. data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh\r\n                 *  2. data:text/plain;charset=UTF-8;page=21,the%20data:1234,5678\r\n                 *  3. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 *  4. data:image/png,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 *  5. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 * @see Syntax {@link https://en.wikipedia.org/wiki/Data_URI_scheme} for more\r\n                 */\n                regex = new RegExp(\"^\\s*data:(.+?\\/.+?(;.+?\\=.+?)*)?(;base64)?,(.*)\\s*$\"),\n                    segments = regex.exec(dataURL);\n                resolve(segments[4]);\n              }, false);\n              reader_1.readAsDataURL(blob_1);\n            })];\n\n          case 7:\n            body = _a.sent();\n            return [3\n            /*break*/\n            , 10];\n\n          case 8:\n            if (!(typeof Buffer !== \"undefined\")) return [3\n            /*break*/\n            , 10];\n            return [4\n            /*yield*/\n            , request.buffer()];\n\n          case 9:\n            buffer = _a.sent();\n            body = buffer.toString(\"base64\");\n            _a.label = 10;\n\n          case 10:\n            bodyParsed = true;\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            e_2 = _a.sent();\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            return [2\n            /*return*/\n            , body];\n        }\n      });\n    });\n  };\n  /**\r\n   * Adds a dependency for a given dependent request\r\n   *\r\n   * @param {string} dependentId - The id of the dependent request\r\n   * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency\r\n   */\n\n\n  BatchRequestContent.prototype.addDependency = function (dependentId, dependencyId) {\n    var self = this;\n\n    if (!self.requests.has(dependentId)) {\n      var error = new Error(\"Dependent \" + dependentId + \" does not exists, Please check the id\");\n      error.name = \"Invalid Dependent\";\n      throw error;\n    }\n\n    if (typeof dependencyId !== \"undefined\" && !self.requests.has(dependencyId)) {\n      var error = new Error(\"Dependency \" + dependencyId + \" does not exists, Please check the id\");\n      error.name = \"Invalid Dependency\";\n      throw error;\n    }\n\n    if (typeof dependencyId !== \"undefined\") {\n      var dependent = self.requests.get(dependentId);\n\n      if (dependent.dependsOn === undefined) {\n        dependent.dependsOn = [];\n      }\n\n      if (dependent.dependsOn.includes(dependencyId)) {\n        var error = new Error(\"Dependency \" + dependencyId + \" is already added for the request \" + dependentId);\n        error.name = \"Duplicate Dependency\";\n        throw error;\n      }\n\n      dependent.dependsOn.push(dependencyId);\n    } else {\n      var prev = void 0,\n          iterator = self.requests.entries(),\n          cur = iterator.next();\n\n      while (!cur.done && cur.value[1].id !== dependentId) {\n        prev = cur;\n        cur = iterator.next();\n      }\n\n      if (typeof prev !== \"undefined\") {\n        var dependencyId_1 = prev.value[0];\n\n        if (cur.value[1].dependsOn === undefined) {\n          cur.value[1].dependsOn = [];\n        }\n\n        if (cur.value[1].dependsOn.includes(dependencyId_1)) {\n          var error = new Error(\"Dependency \" + dependencyId_1 + \" is already added for the request \" + dependentId);\n          error.name = \"Duplicate Dependency\";\n          throw error;\n        }\n\n        cur.value[1].dependsOn.push(dependencyId_1);\n      } else {\n        var error = new Error(\"Can't add dependency \" + dependencyId + \", There is only a dependent request in the batch\");\n        error.name = \"Invalid Dependency Addition\";\n        throw error;\n      }\n    }\n  };\n  /**\r\n   * Removes a dependency for a given dependent request id\r\n   * @param {string} dependentId - The id of the dependent request\r\n   * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request\r\n   * @return The boolean indicating removed status\r\n   */\n\n\n  BatchRequestContent.prototype.removeDependency = function (dependentId, dependencyId) {\n    var request = this.requests.get(dependentId);\n\n    if (typeof request === \"undefined\" || request.dependsOn === undefined || request.dependsOn.length === 0) {\n      return false;\n    }\n\n    if (typeof dependencyId !== \"undefined\") {\n      var index = request.dependsOn.indexOf(dependencyId);\n\n      if (index === -1) {\n        return false;\n      }\n\n      request.dependsOn.splice(index, 1);\n      return true;\n    } else {\n      delete request.dependsOn;\n      return true;\n    }\n  };\n  /**\r\n   * @private\r\n   * @static\r\n   * Limit for number of requests {@link - https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n   */\n\n\n  BatchRequestContent.requestLimit = 20;\n  return BatchRequestContent;\n}();\n\nexports.BatchRequestContent = BatchRequestContent;","map":null,"metadata":{},"sourceType":"script"}
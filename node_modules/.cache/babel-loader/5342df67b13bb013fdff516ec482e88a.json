{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sham/big-calendar/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/sham/big-calendar/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { map, mergeMap, switchMap, catchError } from 'rxjs/operators';\nimport { ofType } from 'redux-observable';\nimport { from } from 'rxjs';\nimport md5 from 'md5';\nimport { RETRIEVE_STORED_EVENTS, BEGIN_STORE_EVENTS, duplicateAction, updateStoredEvents, successStoringEvents, failStoringEvents } from '../../actions/db/events';\nimport getDb from '../../db';\nexport var retrieveEventsEpic = function retrieveEventsEpic(action$) {\n  return action$.pipe(ofType(RETRIEVE_STORED_EVENTS), mergeMap(function () {\n    return from(getDb()).pipe(mergeMap(function (db) {\n      return from(db.events.find().exec()).pipe(map(function (events) {\n        return events.map(function (singleEvent) {\n          return {\n            'id': md5(singleEvent.id),\n            'end': singleEvent.end,\n            'start': singleEvent.start,\n            'summary': singleEvent.summary,\n            'organizer': singleEvent.organizer,\n            'recurrence': singleEvent.recurrence,\n            'iCalUID': singleEvent.iCalUID,\n            'attendees': singleEvent.attendees\n          };\n        });\n      }), map(function (results) {\n        return updateStoredEvents(results);\n      }));\n    }));\n  }));\n};\nexport var storeEventsEpic = function storeEventsEpic(action$) {\n  return action$.pipe(ofType(BEGIN_STORE_EVENTS), mergeMap(function (_ref) {\n    var payload = _ref.payload;\n    filter(payload);\n  }), mergeMap(function (payload) {\n    return from(storeEvents(payload)).pipe(map(function (results) {\n      return successStoringEvents(results);\n    }), catchError(function (error) {\n      return failStoringEvents(error);\n    }));\n  }));\n};\n\nfunction storeEvents(_x) {\n  return _storeEvents.apply(this, arguments);\n}\n\nfunction _storeEvents() {\n  _storeEvents = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(events) {\n    var db, addEvents, results, values;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return getDb();\n\n          case 2:\n            db = _context2.sent;\n            debugger;\n            addEvents = [];\n            results = events.map(\n            /*#__PURE__*/\n            function () {\n              var _ref2 = _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee(dbEvent) {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!dbEvent.id) {\n                          _context.next = 10;\n                          break;\n                        }\n\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return db.events.upsert(dbEvent);\n\n                      case 4:\n                        _context.next = 9;\n                        break;\n\n                      case 6:\n                        _context.prev = 6;\n                        _context.t0 = _context[\"catch\"](1);\n                        return _context.abrupt(\"return\", _context.t0);\n\n                      case 9:\n                        return _context.abrupt(\"return\", dbEvent);\n\n                      case 10:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, this, [[1, 6]]);\n              }));\n\n              return function (_x2) {\n                return _ref2.apply(this, arguments);\n              };\n            }());\n            _context2.next = 8;\n            return Promise.all(results);\n\n          case 8:\n            values = _context2.sent;\n            debugger;\n            return _context2.abrupt(\"return\", values);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n  return _storeEvents.apply(this, arguments);\n}\n\nvar filter = function filter(events) {\n  if (events.data !== undefined) {\n    var formated_events = events.data.map(function (eachEvent) {\n      return {\n        'id': md5(eachEvent.id),\n        'end': eachEvent.end,\n        'start': eachEvent.start,\n        'summary': eachEvent.summary,\n        'organizer': eachEvent.organizer,\n        'recurrence': eachEvent.recurrence,\n        'iCalUID': eachEvent.iCalUID,\n        'attendees': eachEvent.attendees\n      };\n    });\n    return formated_events;\n  } else {\n    return [];\n  }\n};","map":{"version":3,"sources":["/Users/sham/big-calendar/src/epics/db/events.js"],"names":["map","mergeMap","switchMap","catchError","ofType","from","md5","RETRIEVE_STORED_EVENTS","BEGIN_STORE_EVENTS","duplicateAction","updateStoredEvents","successStoringEvents","failStoringEvents","getDb","retrieveEventsEpic","action$","pipe","db","events","find","exec","singleEvent","id","end","start","summary","organizer","recurrence","iCalUID","attendees","results","storeEventsEpic","payload","filter","storeEvents","error","addEvents","dbEvent","upsert","Promise","all","values","data","undefined","formated_events","eachEvent"],"mappings":"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","sourcesContent":["import { map, mergeMap, switchMap, catchError } from 'rxjs/operators';\nimport { ofType } from 'redux-observable';\nimport { from } from 'rxjs';\nimport md5 from 'md5';\nimport {\n  RETRIEVE_STORED_EVENTS,\n  BEGIN_STORE_EVENTS,\n  duplicateAction,\n  updateStoredEvents,\n  successStoringEvents,\n  failStoringEvents\n} from '../../actions/db/events';\nimport getDb from '../../db';\n\nexport const retrieveEventsEpic = action$ => action$.pipe(\n  ofType(RETRIEVE_STORED_EVENTS),\n  mergeMap(() => from(getDb()).pipe(\n    mergeMap(db => from(db.events.find().exec()).pipe(\n        map(events => events.map(singleEvent => {\n              return {\n                  'id' : md5(singleEvent.id),\n                  'end' : singleEvent.end,\n                  'start': singleEvent.start,\n                  'summary': singleEvent.summary,\n                  'organizer': singleEvent.organizer,\n                  'recurrence': singleEvent.recurrence,\n                  'iCalUID': singleEvent.iCalUID,\n                  'attendees': singleEvent.attendees\n                }\n          })\n        ),\n        map(results => {\n          return updateStoredEvents(results);\n            })\n          )\n        )\n      ),\n    ),\n  )\n\nexport const storeEventsEpic = action$ => action$.pipe(\n    ofType(BEGIN_STORE_EVENTS),\n    mergeMap(({payload}) => { filter(payload)}),\n    mergeMap((payload) => from(storeEvents(payload)).pipe(\n      map(results => successStoringEvents(results)),\n      catchError(error => failStoringEvents(error))\n    ))\n  )\n\nasync function storeEvents(events){\n      const db = await getDb();\n      debugger\n      const addEvents = [];\n      const results = events.map(async dbEvent => {\n        if(!!dbEvent.id) {\n          try {\n            await db.events.upsert(dbEvent);\n          } catch(e) {\n            return e;\n          }\n          return dbEvent;\n        }\n      });\n      let values = await Promise.all(results);\n      debugger\n      return values;\n  }\n\nconst filter = (events) => {\n    if(events.data !== undefined) {\n      const formated_events = events.data\n      .map(eachEvent => {\n          return  ({\n            'id' : md5(eachEvent.id),\n            'end' : eachEvent.end,\n            'start': eachEvent.start,\n            'summary': eachEvent.summary,\n            'organizer': eachEvent.organizer,\n            'recurrence': eachEvent.recurrence,\n            'iCalUID': eachEvent.iCalUID,\n            'attendees': eachEvent.attendees\n          })\n        }\n      );\n      return formated_events;\n    }\n    else {\n      return [];\n    }\n  }\n"]},"metadata":{},"sourceType":"module"}
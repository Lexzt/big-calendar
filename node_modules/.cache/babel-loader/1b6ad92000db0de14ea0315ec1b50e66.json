{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar clone = _interopDefault(require('clone'));\n\nvar equal = _interopDefault(require('deep-equal'));\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar isObject = function isObject(variableToCheck) {\n  return (typeof variableToCheck === \"undefined\" ? \"undefined\" : _typeof(variableToCheck)) === \"object\" && variableToCheck !== null;\n};\n\nvar every = function every(arrayToIterate, cb) {\n  return arrayToIterate.every(function (elem) {\n    return cb && cb(elem) || elem;\n  });\n};\n\nvar has = function has(objectWithKeys, key) {\n  return objectWithKeys.hasOwnProperty(key);\n};\n\nvar keys = function keys(objectWithKeys) {\n  return Object.keys(objectWithKeys);\n};\n\nvar each = function each(objectToIterate, cb) {\n  Object.keys(objectToIterate).forEach(function (key) {\n    cb(objectToIterate[key], key);\n  });\n};\n\nvar libIsArray = function libIsArray(variableToCheck) {\n  return Array.isArray(variableToCheck);\n};\n\nvar isBinary = function isBinary(variableToCheck) {\n  return !!(typeof Uint8Array !== 'undefined' && variableToCheck instanceof Uint8Array || variableToCheck && variableToCheck.$Uint8ArrayPolyfill);\n};\n\nvar _$1 = {\n  isArray: libIsArray,\n  each: each\n}; // Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as\n// arrays.\n// XXX maybe this should be EJSON.isArray\n\nvar isArray = function isArray(x) {\n  return _$1.isArray(x) && !isBinary(x);\n};\n\nvar isIndexable = function isIndexable(x) {\n  return isArray(x) || isPlainObject(x);\n}; // Returns true if this is an object with at least one key and all keys begin\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\n// others don't.\n\n\nvar isOperatorObject = function isOperatorObject(valueSelector, inconsistentOK) {\n  if (!isPlainObject(valueSelector)) return false;\n  var theseAreOperators = undefined;\n\n  _$1.each(valueSelector, function (value, selKey) {\n    var thisIsOperator = selKey.substr(0, 1) === '$';\n\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) throw new Error(\"Inconsistent operator: \" + JSON.stringify(valueSelector));\n      theseAreOperators = false;\n    }\n  });\n\n  return !!theseAreOperators; // {} has no operators\n}; // string can be converted to integer\n\n\nvar isNumericKey = function isNumericKey(s) {\n  return /^[0-9]+$/.test(s);\n};\n\nvar isPlainObject = function isPlainObject(variableToCheck) {\n  if (!variableToCheck) return false;\n  if (typeof variableToCheck === \"number\") return false;\n  if (typeof variableToCheck === \"string\") return false;\n  if (typeof variableToCheck === \"boolean\") return false;\n  if (isArray(variableToCheck)) return false;\n  if (variableToCheck === null) return false;\n  if (variableToCheck instanceof RegExp) // note that typeof(/x/) === \"object\"\n    return false;\n  if (typeof variableToCheck === \"function\") return false;\n  if (variableToCheck instanceof Date) return false;\n  if (isBinary(variableToCheck)) return false;\n  return true; // object\n};\n\nvar ModifyJsError = function ModifyJsError(message) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof message === \"string\" && options.field) {\n    message += \" for field '\" + options.field + \"'\";\n  }\n\n  var e = new Error(message);\n  e.name = \"ModifyJsError\";\n  return e;\n};\n\nvar _ = {\n  all: every,\n  each: each,\n  keys: keys,\n  has: has,\n  isObject: isObject\n}; // XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\n\nvar modify = function modify(doc, mod, options) {\n  if (options && options.each) {\n    return;\n  }\n\n  return _modify(doc, mod, _extends({}, options, {\n    returnInsteadOfReplacing: true\n  }));\n};\n\nvar _modify = function _modify(doc, mod, options) {\n  options = options || {};\n  if (!isPlainObject(mod)) throw ModifyJsError(\"Modifier must be an object\"); // Make sure the caller can't mutate our data structures.\n\n  mod = clone(mod);\n  var isModifier = isOperatorObject(mod);\n  var newDoc;\n\n  if (!isModifier) {\n    // replace the whole document\n    newDoc = mod;\n  } else {\n    // apply modifiers to the doc.\n    newDoc = clone(doc);\n\n    _.each(mod, function (operand, op) {\n      var modFunc = MODIFIERS[op]; // Treat $setOnInsert as $set if this is an insert.\n\n      if (!modFunc) throw ModifyJsError(\"Invalid modifier specified \" + op);\n\n      _.each(operand, function (arg, keypath) {\n        if (keypath === '') {\n          throw ModifyJsError(\"An empty update path is not valid.\");\n        }\n\n        var keyparts = keypath.split('.');\n\n        if (!_.all(keyparts)) {\n          throw ModifyJsError(\"The update path '\" + keypath + \"' contains an empty field name, which is not allowed.\");\n        }\n\n        var target = findModTarget(newDoc, keyparts, {\n          noCreate: NO_CREATE_MODIFIERS[op],\n          forbidArray: op === \"$rename\",\n          arrayIndices: options.arrayIndices\n        });\n        var field = keyparts.pop();\n        modFunc(target, field, arg, keypath, newDoc);\n      });\n    });\n  }\n\n  if (options.returnInsteadOfReplacing) {\n    return newDoc;\n  } else {\n    // move new document into place.\n    _.each(_.keys(doc), function (k) {\n      // Note: this used to be for (var k in doc) however, this does not\n      // work right in Opera. Deleting from a doc while iterating over it\n      // would sometimes cause opera to skip some keys.\n      if (k !== '_id') delete doc[k];\n    });\n\n    _.each(newDoc, function (v, k) {\n      doc[k] = v;\n    });\n  }\n}; // for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\n\n\nvar findModTarget = function findModTarget(doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n\n    if (!indexable) {\n      if (options.noCreate) return undefined;\n      var e = ModifyJsError(\"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) return null;\n\n      if (keypart === '$') {\n        if (usedArrayIndex) throw ModifyJsError(\"Too many positional (i.e. '$') elements\");\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw ModifyJsError(\"The positional operator did not find the \" + \"match needed from the query\");\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) return undefined;\n        throw ModifyJsError(\"can't append to array using string field name [\" + keypart + \"]\");\n      }\n\n      if (last) // handle 'a.01'\n        keyparts[i] = keypart;\n      if (options.noCreate && keypart >= doc.length) return undefined;\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) doc.push({});else if (_typeof(doc[keypart]) !== \"object\") throw ModifyJsError(\"can't modify field '\" + keyparts[i + 1] + \"' of list value \" + JSON.stringify(doc[keypart]));\n      }\n    } else {\n      if (!(keypart in doc)) {\n        if (options.noCreate) return undefined;\n        if (!last) doc[keypart] = {};\n      }\n    }\n\n    if (last) return doc;\n    doc = doc[keypart];\n  }\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\nvar MODIFIERS = {\n  $currentDate: function $currentDate(target, field, arg) {\n    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg.hasOwnProperty(\"$type\")) {\n      if (arg.$type !== \"date\") {\n        throw ModifyJsError(\"Minimongo does currently only support the date type \" + \"in $currentDate modifiers\", {\n          field: field\n        });\n      }\n    } else if (arg !== true) {\n      throw ModifyJsError(\"Invalid $currentDate modifier\", {\n        field: field\n      });\n    }\n\n    target[field] = new Date();\n  },\n  $min: function $min(target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw ModifyJsError(\"Modifier $min allowed for numbers only\", {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw ModifyJsError(\"Cannot apply $min modifier to non-number\", {\n          field: field\n        });\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function $max(target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw ModifyJsError(\"Modifier $max allowed for numbers only\", {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw ModifyJsError(\"Cannot apply $max modifier to non-number\", {\n          field: field\n        });\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function $inc(target, field, arg) {\n    if (typeof arg !== \"number\") throw ModifyJsError(\"Modifier $inc allowed for numbers only\", {\n      field: field\n    });\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") throw ModifyJsError(\"Cannot apply $inc modifier to non-number\", {\n        field: field\n      });\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function $set(target, field, arg) {\n    if (!_.isObject(target)) {\n      // not an array or an object\n      var e = ModifyJsError(\"Cannot set property on non-object field\", {\n        field: field\n      });\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (target === null) {\n      var e = ModifyJsError(\"Cannot set property on null\", {\n        field: field\n      });\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    target[field] = arg;\n  },\n  $setOnInsert: function $setOnInsert(target, field, arg) {// converted to `$set` in `_modify`\n  },\n  $unset: function $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) target[field] = null;\n      } else delete target[field];\n    }\n  },\n  $push: function $push(target, field, arg) {\n    if (target[field] === undefined) target[field] = [];\n    if (!(target[field] instanceof Array)) throw ModifyJsError(\"Cannot apply $push modifier to non-array\", {\n      field: field\n    });\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      target[field].push(arg);\n      return;\n    } // Fancy mode: $each (and maybe $slice and $sort and $position)\n\n\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) throw ModifyJsError(\"$each must be an array\", {\n      field: field\n    }); // Parse $position\n\n    var position = undefined;\n\n    if ('$position' in arg) {\n      if (typeof arg.$position !== \"number\") throw ModifyJsError(\"$position must be a numeric value\", {\n        field: field\n      }); // XXX should check to make sure integer\n\n      if (arg.$position < 0) throw ModifyJsError(\"$position in $push must be zero or positive\", {\n        field: field\n      });\n      position = arg.$position;\n    } // Parse $slice.\n\n\n    var slice = undefined;\n\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== \"number\") throw ModifyJsError(\"$slice must be a numeric value\", {\n        field: field\n      }); // XXX should check to make sure integer\n\n      if (arg.$slice > 0) throw ModifyJsError(\"$slice in $push must be zero or negative\", {\n        field: field\n      });\n      slice = arg.$slice;\n    } // Parse $sort.\n\n\n    var sortFunction = undefined;\n\n    if (arg.$sort) {\n      throw ModifyJsError(\"$sort in $push not implemented yet\"); // if (slice === undefined)\n      //   throw ModifyJsError(\"$sort requires $slice to be present\", { field });\n      // // XXX this allows us to use a $sort whose value is an array, but that's\n      // // actually an extension of the Node driver, so it won't work\n      // // server-side. Could be confusing!\n      // // XXX is it correct that we don't do geo-stuff here?\n      // sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      // for (var i = 0; i < toPush.length; i++) {\n      //   if (_f._type(toPush[i]) !== 3) {\n      //     throw ModifyJsError(\"$push like modifiers using $sort \" +\n      //                 \"require all elements to be objects\", { field });\n      //   }\n      // }\n    } // Actually push.\n\n\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++) {\n        target[field].push(toPush[j]);\n      }\n    } else {\n      var spliceArguments = [position, 0];\n\n      for (var j = 0; j < toPush.length; j++) {\n        spliceArguments.push(toPush[j]);\n      }\n\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    } // Actually sort.\n\n\n    if (sortFunction) target[field].sort(sortFunction); // Actually slice.\n\n    if (slice !== undefined) {\n      if (slice === 0) target[field] = []; // differs from Array.slice!\n      else target[field] = target[field].slice(slice);\n    }\n  },\n  $pushAll: function $pushAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg instanceof Array)) throw ModifyJsError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    var x = target[field];\n    if (x === undefined) target[field] = arg;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pushAll modifier to non-array\", {\n      field: field\n    });else {\n      for (var i = 0; i < arg.length; i++) {\n        x.push(arg[i]);\n      }\n    }\n  },\n  $addToSet: function $addToSet(target, field, arg) {\n    var isEach = false;\n\n    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\") {\n      //check if first key is '$each'\n      var _keys = Object.keys(arg);\n\n      if (_keys[0] === \"$each\") {\n        isEach = true;\n      }\n    }\n\n    var values = isEach ? arg[\"$each\"] : [arg];\n    var x = target[field];\n    if (x === undefined) target[field] = values;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $addToSet modifier to non-array\", {\n      field: field\n    });else {\n      _.each(values, function (value) {\n        for (var i = 0; i < x.length; i++) {\n          if (equal(value, x[i])) return;\n        }\n\n        x.push(value);\n      });\n    }\n  },\n  $pop: function $pop(target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pop modifier to non-array\", {\n      field: field\n    });else {\n      if (typeof arg === 'number' && arg < 0) x.splice(0, 1);else x.pop();\n    }\n  },\n  $pull: function $pull(target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pull/pullAll modifier to non-array\", {\n      field: field\n    });else {\n      throw ModifyJsError(\"$pull not implemented yet\"); // var out = [];\n      // if (arg != null && typeof arg === \"object\" && !(arg instanceof Array)) {\n      //   // XXX would be much nicer to compile this once, rather than\n      //   // for each document we modify.. but usually we're not\n      //   // modifying that many documents, so we'll let it slide for\n      //   // now\n      //\n      //   // XXX Minimongo.Matcher isn't up for the job, because we need\n      //   // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n      //   // like {$gt: 4} is not normally a complete selector.\n      //   // same issue as $elemMatch possibly?\n      //   var matcher = new Minimongo.Matcher(arg);\n      //   for (var i = 0; i < x.length; i++)\n      //     if (!matcher.documentMatches(x[i]).result)\n      //       out.push(x[i]);\n      // } else {\n      //   for (var i = 0; i < x.length; i++)\n      //     if (!_f._equal(x[i], arg))\n      //       out.push(x[i]);\n      // }\n      // target[field] = out;\n    }\n  },\n  $pullAll: function $pullAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && arg instanceof Array)) throw ModifyJsError(\"Modifier $pushAll/pullAll allowed for arrays only\", {\n      field: field\n    });\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw ModifyJsError(\"Cannot apply $pull/pullAll modifier to non-array\", {\n      field: field\n    });else {\n      var out = [];\n\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n\n        for (var j = 0; j < arg.length; j++) {\n          if (equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n\n        if (!exclude) out.push(x[i]);\n      }\n\n      target[field] = out;\n    }\n  },\n  $rename: function $rename(target, field, arg, keypath, doc) {\n    if (keypath === arg) // no idea why mongo has this restriction..\n      throw ModifyJsError(\"$rename source must differ from target\", {\n        field: field\n      });\n    if (target === null) throw ModifyJsError(\"$rename source field invalid\", {\n      field: field\n    });\n    if (typeof arg !== \"string\") throw ModifyJsError(\"$rename target must be a string\", {\n      field: field\n    });\n\n    if (arg.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw ModifyJsError(\"The 'to' field for $rename cannot contain an embedded null byte\", {\n        field: field\n      });\n    }\n\n    if (target === undefined) return;\n    var v = target[field];\n    delete target[field];\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {\n      forbidArray: true\n    });\n    if (target2 === null) throw ModifyJsError(\"$rename target field invalid\", {\n      field: field\n    });\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw ModifyJsError(\"$bit is not supported\", {\n      field: field\n    });\n  }\n};\nmodule.exports = modify;","map":null,"metadata":{},"sourceType":"script"}
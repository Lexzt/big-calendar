{"ast":null,"code":"/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport objectPath from 'object-path';\nimport RxDocument from '../rx-document';\nimport RxError from '../rx-error';\nimport { getIndexes } from '../rx-schema';\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @param  {string} fieldName\n * @throws {Error}\n */\n\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '') return;\n  if (fieldName === '_id') return;\n\n  if (['properties', 'language'].includes(fieldName)) {\n    throw RxError.newRxError('SC23', {\n      fieldName: fieldName\n    });\n  }\n\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n\n  if (!fieldName.match(regex)) {\n    throw RxError.newRxError('SC1', {\n      regex: regexStr,\n      fieldName: fieldName\n    });\n  }\n}\n/**\n * validate that all schema-related things are ok\n * @param  {object} jsonSchema\n * @return {boolean} true always\n */\n\nexport function validateFieldsDeep(jsonSchema) {\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj)) checkFieldNameRegex(fieldName); // 'item' only allowed it type=='array'\n\n    if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n      throw RxError.newRxError('SC2', {\n        fieldName: fieldName\n      });\n    }\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n\n\n    if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n      throw RxError.newRxError('SC24', {\n        fieldName: fieldName\n      });\n    } // if ref given, must be type=='string' or type=='array' with string-items\n\n\n    if (schemaObj.hasOwnProperty('ref')) {\n      switch (schemaObj.type) {\n        case 'string':\n          break;\n\n        case 'array':\n          if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n            throw RxError.newRxError('SC3', {\n              fieldName: fieldName\n            });\n          }\n\n          break;\n\n        default:\n          throw RxError.newRxError('SC4', {\n            fieldName: fieldName\n          });\n      }\n    } // if primary is ref, throw\n\n\n    if (schemaObj.hasOwnProperty('ref') && schemaObj.primary) {\n      throw RxError.newRxError('SC5', {\n        fieldName: fieldName\n      });\n    }\n\n    var isNested = path.split('.').length >= 2; // nested only\n\n    if (isNested) {\n      if (schemaObj.primary) {\n        throw RxError.newRxError('SC6', {\n          path: path,\n          primary: schemaObj.primary\n        });\n      }\n\n      if (schemaObj[\"default\"]) {\n        throw RxError.newRxError('SC7', {\n          path: path\n        });\n      }\n    } // first level\n\n\n    if (!isNested) {\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (fieldName === '_id' && schemaObj.primary) {\n          return;\n        }\n\n        throw RxError.newRxError('SC8', {\n          fieldName: fieldName\n        });\n      }\n    }\n  }\n\n  function traverse(currentObj, currentPath) {\n    if (typeof currentObj !== 'object') return;\n\n    for (var attributeName in currentObj) {\n      if (!currentObj.properties) {\n        checkField(attributeName, currentObj[attributeName], currentPath);\n      }\n\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(currentObj[attributeName], nextPath);\n    }\n  }\n\n  traverse(jsonSchema, '');\n  return true;\n}\n/**\n * does the checking\n * @param  {object} jsonId json-object like in json-schema-standard\n * @throws {Error} if something is not ok\n */\n\nexport function checkSchema(jsonID) {\n  // check _rev\n  if (jsonID.properties._rev) {\n    throw RxError.newRxError('SC10', {\n      schema: jsonID\n    });\n  } // check version\n\n\n  if (!jsonID.hasOwnProperty('version') || typeof jsonID.version !== 'number' || jsonID.version < 0) {\n    throw RxError.newRxError('SC11', {\n      version: jsonID.version\n    });\n  }\n\n  validateFieldsDeep(jsonID);\n  var primaryPath;\n  Object.keys(jsonID.properties).forEach(function (key) {\n    var value = jsonID.properties[key]; // check primary\n\n    if (value.primary) {\n      if (primaryPath) {\n        throw RxError.newRxError('SC12', {\n          value: value\n        });\n      }\n\n      primaryPath = key;\n\n      if (value.index) {\n        throw RxError.newRxError('SC13', {\n          value: value\n        });\n      }\n\n      if (value.unique) {\n        throw RxError.newRxError('SC14', {\n          value: value\n        });\n      }\n\n      if (value.encrypted) {\n        throw RxError.newRxError('SC15', {\n          value: value\n        });\n      }\n\n      if (value.type !== 'string') {\n        throw RxError.newRxError('SC16', {\n          value: value\n        });\n      }\n    } // check if RxDocument-property\n\n\n    if (RxDocument.properties().includes(key)) {\n      throw RxError.newRxError('SC17', {\n        key: key\n      });\n    }\n  }); // check format of jsonID.compoundIndexes\n\n  if (jsonID.compoundIndexes) {\n    if (!Array.isArray(jsonID.compoundIndexes)) {\n      throw RxError.newRxError('SC18', {\n        compoundIndexes: jsonID.compoundIndexes\n      });\n    }\n\n    jsonID.compoundIndexes.forEach(function (ar) {\n      if (!Array.isArray(ar)) {\n        throw RxError.newRxError('SC19', {\n          compoundIndexes: jsonID.compoundIndexes\n        });\n      }\n\n      ar.forEach(function (str) {\n        if (typeof str !== 'string') {\n          throw RxError.newRxError('SC20', {\n            compoundIndexes: jsonID.compoundIndexes\n          });\n        }\n      });\n    });\n  } // check that indexes are string or number\n\n\n  getIndexes(jsonID).reduce(function (a, b) {\n    return a.concat(b);\n  }, []).filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  }) // unique\n  .map(function (key) {\n    var path = 'properties.' + key.replace(/\\./g, '.properties.');\n    var schemaObj = objectPath.get(jsonID, path);\n\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw RxError.newRxError('SC21', {\n        key: key\n      });\n    }\n\n    return {\n      key: key,\n      schemaObj: schemaObj\n    };\n  }).filter(function (index) {\n    return index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number';\n  }).forEach(function (index) {\n    throw RxError.newRxError('SC22', {\n      key: index.key,\n      type: index.schemaObj.type\n    });\n  });\n}\nexport var rxdb = true;\nexport var hooks = {\n  preCreateRxSchema: checkSchema\n};\nexport default {\n  rxdb: rxdb,\n  hooks: hooks\n};","map":null,"metadata":{},"sourceType":"module"}